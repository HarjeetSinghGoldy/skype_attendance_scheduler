import { createInvalidDocumentError } from "../errors/invalid-document";
import { name as typeName, renameKeys } from "../types/document";
export function register(serializer) {
    function write(type, val) {
        const result = {}; // Object.create(null);
        for (const [key, outKey] of renameKeys(type.properties, type.rename)) {
            const descriptor = type.properties[key];
            const value = val[key];
            if (value === undefined) {
                Reflect.set(result, outKey, undefined);
            }
            else {
                Reflect.set(result, outKey, serializer.write(descriptor.type, value));
            }
        }
        return result;
    }
    function read(type, input) {
        const extra = type.ignoreExtraKeys ? undefined : new Set(Object.keys(input));
        const missing = new Set();
        const invalid = new Map();
        const result = {}; // Object.create(null);
        for (const [key, outKey] of renameKeys(type.properties, type.rename)) {
            if (extra !== undefined) {
                extra.delete(outKey);
            }
            const descriptor = type.properties[key];
            const outValue = Reflect.get(input, outKey);
            if (outValue === undefined) {
                if (descriptor.optional) {
                    result[key] = undefined;
                }
                else {
                    missing.add(key);
                }
                continue;
            }
            try {
                result[key] = serializer.read(descriptor.type, outValue);
            }
            catch (err) {
                invalid.set(key, err);
            }
        }
        if (extra !== undefined && extra.size > 0 || missing.size > 0 || invalid.size > 0) {
            throw createInvalidDocumentError({ extra, missing, invalid });
        }
        return result;
    }
    function readTrusted(type, input) {
        const result = {}; // Object.create(null);
        for (const [key, outKey] of renameKeys(type.properties, type.rename)) {
            const descriptor = type.properties[key];
            const outValue = Reflect.get(input, outKey);
            if (outValue === undefined) {
                result[key] = undefined;
            }
            else {
                result[key] = serializer.readTrusted(descriptor.type, outValue);
            }
        }
        return result;
    }
    serializer.register({
        typeName,
        write,
        read,
        readTrusted,
    });
}
