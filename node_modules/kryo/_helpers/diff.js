"use strict";
// Implementation of the Hirschberg algorithm
// Time: O(mn)
// Space: O(min(m, n))
// See: https://en.wikipedia.org/wiki/Hirschberg%27s_algorithm
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Represents a slice of a sequence of items. This allows to abstract the access to the items
 * and prevent extraneous copies of the sequence.
 */
class Slice {
    constructor(sequence, start, end, reversed) {
        this.sequence = sequence;
        this.start = start;
        this.end = end;
        this.length = end - start;
        this.reversed = reversed;
    }
    indexOf(item) {
        if (this.reversed) {
            for (let i = this.end - 1; i >= this.start; i--) {
                if (this.sequence[i] === item) {
                    return this.end - 1 - i;
                }
            }
        }
        else {
            for (let i = this.start; i < this.end; i++) {
                if (this.sequence[i] === item) {
                    return i - this.start;
                }
            }
        }
        return -1;
    }
    getItem(index) {
        return this.sequence[this.getAbsoluteIndex(index)];
    }
    getAbsoluteIndex(relativeIndex) {
        if (this.reversed) {
            return (this.end - 1) - relativeIndex;
        }
        else {
            return this.start + relativeIndex;
        }
    }
    split(index) {
        if (this.reversed) {
            throw Error("Cannot split reversed");
        }
        const left = new Slice(this.sequence, this.start, this.start + index, false);
        const right = new Slice(this.sequence, this.start + index, this.end, false);
        return [left, right];
    }
    reverse() {
        return new Slice(this.sequence, this.start, this.end, true);
    }
}
function nearestEnd(src, target) {
    const xSeq = src.sequence;
    const x1 = 0;
    const x2 = src.length;
    const ySeq = target.sequence;
    const y1 = 0;
    const y2 = target.length;
    const xLen = x2 - x1;
    const yLen = y2 - y1;
    // We do not need to store the whole matrix: we just need the current and
    // previous rows.
    let oldDist = Array(yLen + 1);
    let curDist = Array(yLen + 1);
    // Fill the first row
    for (let col = 0; col <= yLen; col++) {
        curDist[col] = col;
    }
    // Traverse xSeq
    for (let row = 1; row <= xLen; row++) {
        [curDist, oldDist] = [oldDist, curDist];
        const rowItem = src.getItem(row - 1);
        // Initialize first column
        curDist[0] = row;
        // Compute distances
        for (let col = 1; col <= yLen; col++) {
            // Nearest distance in case of ADD or DEL
            const addDelDist = Math.min(oldDist[col], curDist[col - 1]) + 1;
            // Nearest distance in case of MATCH
            const matchDist = oldDist[col - 1];
            // Nearest distance in case of MUT
            const mutDist = matchDist + 1;
            if (addDelDist <= matchDist) {
                // See the comment above about skipping the test `colItem === rowItem`
                curDist[col] = addDelDist;
            }
            else {
                const colItem = target.getItem(col - 1);
                curDist[col] = colItem === rowItem ? matchDist : mutDist;
            }
        }
    }
    // Search for minimum in the last line
    let minDistCol = 0;
    for (let col = 1; col <= yLen; col++) {
        // We use equality to get the rightmost minimal value.
        if (curDist[col] <= curDist[minDistCol]) {
            minDistCol = col;
        }
    }
    const minDistIndex = minDistCol - 1;
    const minDistValue = curDist[minDistCol];
    return [minDistIndex, minDistValue];
}
function hirschberg(source, target) {
    const srcLen = source.length;
    const tarLen = target.length;
    if (srcLen === 0 || tarLen === 0) {
        if (srcLen > 0) {
            return [{ type: "source", value: srcLen }];
        }
        else if (tarLen > 0) {
            return [{ type: "target", value: tarLen }];
        }
        else {
            return [];
        }
    }
    else if (srcLen === 1 || tarLen === 1) {
        let idx = source.indexOf(target.getItem(0));
        if (srcLen > 1 && idx >= 0) {
            return [
                { type: "source", value: idx },
                { type: "match", value: 1 },
                { type: "source", value: srcLen - idx - 1 },
            ];
        }
        else {
            idx = target.indexOf(source.getItem(0));
            if (idx >= 0) {
                return [
                    { type: "target", value: idx },
                    { type: "match", value: 1 },
                    { type: "target", value: tarLen - idx - 1 },
                ];
            }
            else {
                return [
                    { type: "source", value: srcLen },
                    { type: "target", value: tarLen },
                ];
            }
        }
    }
    else {
        const srcMid = Math.floor(srcLen / 2);
        const [srcLeft, srcRight] = source.split(srcMid);
        const [leftMinDistIdx, leftMinVal] = nearestEnd(srcLeft, target);
        const [rightMinDistIdx, rightMinVal] = nearestEnd(srcRight.reverse(), target.reverse());
        let targetMid;
        if (leftMinVal <= rightMinVal) {
            // We add one because the right of the range is exclusive
            targetMid = leftMinDistIdx + 1;
        }
        else {
            // Convert the right index from the reversed tarRight to target
            targetMid = (target.length - 1) - rightMinDistIdx;
        }
        const [tarLeft, tarRight] = target.split(targetMid);
        const left = hirschberg(srcLeft, tarLeft);
        const right = hirschberg(srcRight, tarRight);
        return [...left, ...right];
    }
}
function normalizeDiff(diff) {
    const result = [];
    if (diff.length === 0) {
        return result;
    }
    let curSource = 0;
    let curTarget = 0;
    let curBoth = 0;
    for (const action of diff) {
        if (action.value === 0) {
            continue;
        }
        if (action.type === "match") {
            if (curSource > 0) {
                result.push({ type: "source", value: curSource });
                curSource = 0;
            }
            if (curTarget > 0) {
                result.push({ type: "target", value: curTarget });
                curTarget = 0;
            }
            curBoth += action.value;
        }
        else {
            if (curBoth > 0) {
                result.push({ type: "match", value: curBoth });
                curBoth = 0;
            }
            if (action.type === "source") {
                curSource += action.value;
            }
            else {
                curTarget += action.value;
            }
        }
    }
    if (curSource > 0) {
        result.push({ type: "source", value: curSource });
    }
    if (curTarget > 0) {
        result.push({ type: "target", value: curTarget });
    }
    if (curBoth > 0) {
        result.push({ type: "match", value: curBoth });
    }
    return result;
}
exports.normalizeDiff = normalizeDiff;
function diffSync(seq1, seq2) {
    return normalizeDiff(hirschberg(new Slice(seq1, 0, seq1.length, false), new Slice(seq2, 0, seq2.length, false)));
}
exports.diffSync = diffSync;
/*
 * Structure of the Levenshtein matrix
 *
 * Let's see which information about the grid we can get from the equation
 * of `r`.
 * By definition of `min`, we have:
 *
 * ```
 * ┼─┼─┼
 * │m│a│   r <= m + 1  (This is true independently of `isMatch`)        [eq. 03]
 * ┼─┼─┼   r <= a + 1                                                   [eq. 04]
 * │d│r│   r <= d + 1                                                   [eq. 05]
 * ┼─┼─┼
 * ```
 *
 * This means that growth of the distance when we go to the right or down is
 * bounded. You cannot increase of more than 1 when going to the right or down.
 *
 * It means that the following configurations are impossible:
 *
 * ```
 * ┼─┼─┼
 * │5│ │   IMPOSSIBLE, breaks: r <= m + 1
 * ┼─┼─┼
 * │ │7│
 * ┼─┼─┼
 *
 * ┼─┼─┼
 * │ │5│   IMPOSSIBLE, breaks: r <= a + 1
 * ┼─┼─┼
 * │ │7│
 * ┼─┼─┼
 *
 * ┼─┼─┼
 * │ │ │   IMPOSSIBLE, breaks: r <= d + 1
 * ┼─┼─┼
 * │5│7│
 * ┼─┼─┼
 * ```
 *
 * Since these inequalities are relative to a `r`, we can translate them:
 * ```
 * ┼─┼─┼
 * │m│a│   d <= m + 1   (from [eq. 4])                                  [eq. 06]
 * ┼─┼─┼   a <= m + 1   (from [eq. 5])                                  [eq. 07]
 * │d│r│
 * ┼─┼─┼
 * ```
 *
 * We can also add a lower bound to the growth when going to the right or down:
 * ```
 * a - 1 <= r                                                           [eq. 08]
 * d - 1 <= r                                                           [eq. 09]
 * ```
 * So `r` cannot grow faster than `1` per cell, but also cannot decrease faster.
 *
 * This means that the following configuration are impossible:
 *
 * ```
 * ┼─┼─┼
 * │ │7│   IMPOSSIBLE, breaks: a - 1 <= r
 * ┼─┼─┼
 * │ │5│
 * ┼─┼─┼
 *
 * ┼─┼─┼
 * │ │ │   IMPOSSIBLE, breaks: d - 1 <= r
 * ┼─┼─┼
 * │7│5│
 * ┼─┼─┼
 * ```
 *
 * We will only prove the first inequality `a - 1 <= r` since both inequalities
 * are in fact equivalent due to the symmetry of the problem.
 *
 * To demonstrate it, we'll use a proof by contradiction: we will show that it
 * simply cannot be otherwise.
 * The opposite of `a - 1 <= r` is:
 * ```
 * a - 1 > r                                                            [eq. 10]
 * ```
 * This inequality is incompatible with the value of `r` whether it comes from
 * a MATCH, MUT, ADD or DEL:
 *
 *
 * MATCH:
 * ```
 * r = m              (definition of MATCH)
 * a - 1 > r          (hypothesis)
 * a <= m + 1         (previous constraint [eq. 07])
 * ```
 * We can transform it:
 * ```
 * r = m
 * a > r + 1          (move `-1` to the right side)
 * a <= r + 1         (substitute `m` for `r`)
 * ```
 * This system does not have any solution.
 *
 * MUT:
 * ```
 * r = m + 1          (definition of MUT)
 * a - 1 > r          (hypothesis)
 * a <= m + 1         (previous constraint [eq. 07])
 * ```
 * We can transform it:
 * ```
 * r = m
 * a > r + 1          (move `-1` to the right side)
 * a <= r             (substitute `m + 1` for `r`)
 * ```
 * This system does not have any solution.
 *
 *
 * ADD:
 * ```
 * r = a + 1          (definition of ADD)
 * a - 1 > r          (hypothesis)
 * ```
 * This system does not have any solution.
 *
 *
 * DEL:
 * So far we've seen that the MATCH, MUT and ADD for `r` are incompatible
 * with `a - 1 > r`. Let's check the last case: DEL.
 *
 * ```
 * r = d + 1          (definition of DEL)
 * a - 1 > r          (hypothesis)
 * a <= m + 1         (previous constraint)
 * ```
 * We can transform it:
 * ```
 * r - 1 = d          (move `1` to the left)
 * a > r + 1          (move `-1` to the right)
 * m + 1 >= a         (swap)
 * ```
 * And again:
 * ```
 * d = r - 1          (swap)
 * a > r + 1
 * m + 1 >= a
 * m + 1 > r + 1      (transitivity with line 2 and 3: m + 1 >= a > r + 1)
 * ```
 * And again:
 * ```
 * d = r - 1          (swap)
 * a > r + 1
 * m + 1 >= a
 * m > r              (cancel `1`)
 * ```
 * And again:
 * ```
 * d = r - 1
 * a > r + 1
 * m + 1 >= a
 * m > d + 1          (Substitute `r` for `d+1`)
 * ```
 * We can place these equations on the grid to better visualize the situation.
 * ```
 * ┼─────┼─────┼
 * │> d+1│> r+1│
 * ┼─────┼─────┼
 * │  d  │  r  │
 * ┼─────┼─────┼
 *
 * ```
 *
 * If we recap what we know:
 *
 * The cell above `r` can have a value (strictly) greater than `r + 1`
 * IF
 * The cell above `d` has a value (strictly) greater than `d + 1`.
 *
 * So to have a decrease of 2 or more between one cell and the cell below, we
 * have to have a decrease of 2 or more on the column to the left.
 * Recursively, to have a decrease of 2 or more on the column `j-1`, we need
 * this decrease on `j-2` so also on `j-3` and also on `j-4` and so on until we
 * reach the leftmost column...
 *
 * > The top row is initialized with integers from 0 to `n`, the left column
 * > with integers from 0 to `m`.
 *
 * The leftmost column is strictly increasing so it does not contain any
 * decrease of two or more. This means that the pattern described above is
 * impossible and `a - 1 > r` is not possible with a DEL operation.
 *
 * `a - 1 > r` is not possible with any operation, it is always false.
 * So, its opposite `a - 1 <= r` is always true. Or we could just have said that
 * the problem is symmetric if we reverse both strings.
 */

//# sourceMappingURL=data:application/json;charset=utf8;base64,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QUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLEVBQUUsSUFBSSxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNuSCxDQUFDO0FBRkQsNEJBRUM7QUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQThMRyIsImZpbGUiOiJfaGVscGVycy9kaWZmLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wbGVtZW50YXRpb24gb2YgdGhlIEhpcnNjaGJlcmcgYWxnb3JpdGhtXG4vLyBUaW1lOiBPKG1uKVxuLy8gU3BhY2U6IE8obWluKG0sIG4pKVxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IaXJzY2hiZXJnJTI3c19hbGdvcml0aG1cblxuLypcbiAqIExldmVuc2h0ZWluIGRpc3RhbmNlXG4gKlxuICogVGhlIGRpc3RhbmNlIGlzIGNhbGN1bGF0ZSB3aXRoIGEgZ3JpZCBvZiBuKzEgY29sdW1ucyBhbmQgbSsxIGxpbmVzLlxuICpcbiAqIFRoZSB0b3Agcm93IGlzIGluaXRpYWxpemVkIHdpdGggaW50ZWdlcnMgZnJvbSAwIHRvIGBuYCwgdGhlIGxlZnQgY29sdW1uIHdpdGhcbiAqIGludGVnZXJzIGZyb20gMCB0byBgbWAuXG4gKlxuICogVGhlbiwgd2UgZmlsbCB0aGUgZ3JpZCB3aXRoIHRoZSBmb2xsb3dpbmcgZXF1YXRpb246XG4gKlxuICogYGBgXG4gKiDilLzilIDilLzilIDilLwgICByID0gbWluKGEgKyAxLCBkICsgMSwgaXNNYXRjaCA/IG0gOiBtICsgMSkgICAgICAgICAgICAgICAgICAgW2VxLiAwMV1cbiAqIOKUgm3ilIJh4pSCICAgICAgICAgICDilJTilIDilKzilIDilJggIOKUlOKUgOKUrOKUgOKUmCAgICAgICAgICAgIOKUgiAgIOKUlOKUgOKUrOKUgOKUmFxuICog4pS84pSA4pS84pSA4pS8ICAgICAgICAgICAgQUREICAgIERFTCAgICAgICAgICBNQVRDSCAgIE1VVFxuICog4pSCZOKUgnLilIJcbiAqIOKUvOKUgOKUvOKUgOKUvFxuICogYGBgXG4gKlxuICogVGhlIHJlc3VsdCBkaXN0YW5jZSBjYW4gYmUgb2J0YWluZWQgZnJvbSB0aGUgZGlzdGFuY2VzIG9mIHByZWZpeGVzLlxuICogVGhlIHZhbHVlIG9idGFpbmVkIGZyb20gdGhlIGRpc3RhbmNlIGBtYCBkZXBlbmRzIG9uIHRoZSBjb21wYXJpc29uIG9mIHRoZVxuICogY3VycmVudCBpdGVtcyAoaXNNYXRjaCBtZWFucyB0aGF0IHRoZSBpdGVtcyBhcmUgZXF1YWwpLiBUaGUgZXF1YWxpdHkgdGVzdCBjYW5cbiAqIGJlIGV4cGVuc2l2ZSBzbyB3ZSB3YW50IHRvIGF2b2lkIGl0IHdoZW4gcG9zc2libGUuXG4gKiBXZSBjYW4gYXZvaWQgdGhlIHRlc3QgaWYgdGhlIGZvbGxvd2luZyBlcXVhbGl0eSBpcyB0cnVlOlxuICogYGBgXG4gKiBtaW4oYSArIDEsIGQgKyAxKSA8PSBtICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZXEuIDAyXVxuICogYGBgXG4gKiAoSW4gdGhpcyBjYXNlLCBldmVuIGlmIHdlIGdldCBhIG1hdGNoIGl0IHdpbGwgbm90IGNoYW5nZSB0aGUgdmFsdWUgb2YgYHJgKVxuICpcbiAqL1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzZXF1ZW5jZSBvZiBpdGVtczogZWl0aGVyIGEgc3RyaW5nIG9yIGFuIGFycmF5LlxuICovXG5pbnRlcmZhY2UgU2VxdWVuY2U8VD4ge1xuICBsZW5ndGg6IG51bWJlcjtcbiAgW2luZGV4OiBudW1iZXJdOiBUO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzbGljZSBvZiBhIHNlcXVlbmNlIG9mIGl0ZW1zLiBUaGlzIGFsbG93cyB0byBhYnN0cmFjdCB0aGUgYWNjZXNzIHRvIHRoZSBpdGVtc1xuICogYW5kIHByZXZlbnQgZXh0cmFuZW91cyBjb3BpZXMgb2YgdGhlIHNlcXVlbmNlLlxuICovXG5jbGFzcyBTbGljZTxUPiB7XG4gIC8qKlxuICAgKiBUaGUgb3JpZ2luYWwgc2VxdWVuY2UuXG4gICAqL1xuICBzZXF1ZW5jZTogU2VxdWVuY2U8VD47XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgc2xpY2UsIHJlbGF0aXZlIHRvIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZS5cbiAgICovXG4gIHN0YXJ0OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBpbmRleCAqKmFmdGVyKiogdGhlIGxhc3QgaXRlbSBpbiB0aGUgc2xpY2UsIHJlbGF0aXZlIHRvIHRoZSBvcmlnaW5hbCBzZXF1ZW5jZS5cbiAgICovXG4gIGVuZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgbGVuZ3RoIG9mIHRoZSBzbGljZS5cbiAgICovXG4gIGxlbmd0aDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBSZXZlcnNlIHRoZSBhY2Nlc3MgdG8gdGhlIGl0ZW1zOiBzbGljZS5nZXQoMCkgd2lsbCByZXR1cm4gdGhlIGxhc3QgaXRlbSBpbnN0ZWFkIG9mIHRoZSBmaXJzdC5cbiAgICovXG4gIHJldmVyc2VkOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKHNlcXVlbmNlOiBTZXF1ZW5jZTxUPiwgc3RhcnQ6IG51bWJlciwgZW5kOiBudW1iZXIsIHJldmVyc2VkOiBib29sZWFuKSB7XG4gICAgdGhpcy5zZXF1ZW5jZSA9IHNlcXVlbmNlO1xuICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcbiAgICB0aGlzLmVuZCA9IGVuZDtcbiAgICB0aGlzLmxlbmd0aCA9IGVuZCAtIHN0YXJ0O1xuICAgIHRoaXMucmV2ZXJzZWQgPSByZXZlcnNlZDtcbiAgfVxuXG4gIGluZGV4T2YoaXRlbTogVCk6IG51bWJlciB7XG4gICAgaWYgKHRoaXMucmV2ZXJzZWQpIHtcbiAgICAgIGZvciAobGV0IGk6IG51bWJlciA9IHRoaXMuZW5kIC0gMTsgaSA+PSB0aGlzLnN0YXJ0OyBpLS0pIHtcbiAgICAgICAgaWYgKHRoaXMuc2VxdWVuY2VbaV0gPT09IGl0ZW0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbmQgLSAxIC0gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBpOiBudW1iZXIgPSB0aGlzLnN0YXJ0OyBpIDwgdGhpcy5lbmQ7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5zZXF1ZW5jZVtpXSA9PT0gaXRlbSkge1xuICAgICAgICAgIHJldHVybiBpIC0gdGhpcy5zdGFydDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICBnZXRJdGVtKGluZGV4OiBudW1iZXIpOiBUIHtcbiAgICByZXR1cm4gdGhpcy5zZXF1ZW5jZVt0aGlzLmdldEFic29sdXRlSW5kZXgoaW5kZXgpXTtcbiAgfVxuXG4gIGdldEFic29sdXRlSW5kZXgocmVsYXRpdmVJbmRleDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBpZiAodGhpcy5yZXZlcnNlZCkge1xuICAgICAgcmV0dXJuICh0aGlzLmVuZCAtIDEpIC0gcmVsYXRpdmVJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnQgKyByZWxhdGl2ZUluZGV4O1xuICAgIH1cbiAgfVxuXG4gIHNwbGl0KGluZGV4OiBudW1iZXIpOiBbU2xpY2U8VD4sIFNsaWNlPFQ+XSB7XG4gICAgaWYgKHRoaXMucmV2ZXJzZWQpIHtcbiAgICAgIHRocm93IEVycm9yKFwiQ2Fubm90IHNwbGl0IHJldmVyc2VkXCIpO1xuICAgIH1cbiAgICBjb25zdCBsZWZ0OiBTbGljZTxUPiA9IG5ldyBTbGljZSh0aGlzLnNlcXVlbmNlLCB0aGlzLnN0YXJ0LCB0aGlzLnN0YXJ0ICsgaW5kZXgsIGZhbHNlKTtcbiAgICBjb25zdCByaWdodDogU2xpY2U8VD4gPSBuZXcgU2xpY2UodGhpcy5zZXF1ZW5jZSwgdGhpcy5zdGFydCArIGluZGV4LCB0aGlzLmVuZCwgZmFsc2UpO1xuICAgIHJldHVybiBbbGVmdCwgcmlnaHRdO1xuICB9XG5cbiAgcmV2ZXJzZSgpOiBTbGljZTxUPiB7XG4gICAgcmV0dXJuIG5ldyBTbGljZSh0aGlzLnNlcXVlbmNlLCB0aGlzLnN0YXJ0LCB0aGlzLmVuZCwgdHJ1ZSk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBEaWZmQWN0aW9uIHtcbiAgdHlwZTogXCJzb3VyY2VcIiB8IFwidGFyZ2V0XCIgfCBcIm1hdGNoXCI7XG4gIHZhbHVlOiBudW1iZXI7XG59XG5cbnR5cGUgSW5kZXhWYWx1ZSA9IFtudW1iZXIsIG51bWJlcl07XG5cbmZ1bmN0aW9uIG5lYXJlc3RFbmQgPFQ+KHNyYzogU2xpY2U8VD4sIHRhcmdldDogU2xpY2U8VD4pOiBJbmRleFZhbHVlIHtcbiAgY29uc3QgeFNlcTogU2VxdWVuY2U8VD4gPSBzcmMuc2VxdWVuY2U7XG4gIGNvbnN0IHgxOiBudW1iZXIgPSAwO1xuICBjb25zdCB4MjogbnVtYmVyID0gc3JjLmxlbmd0aDtcbiAgY29uc3QgeVNlcTogU2VxdWVuY2U8VD4gPSB0YXJnZXQuc2VxdWVuY2U7XG4gIGNvbnN0IHkxOiBudW1iZXIgPSAwO1xuICBjb25zdCB5MjogbnVtYmVyID0gdGFyZ2V0Lmxlbmd0aDtcbiAgY29uc3QgeExlbjogbnVtYmVyID0geDIgLSB4MTtcbiAgY29uc3QgeUxlbjogbnVtYmVyID0geTIgLSB5MTtcblxuICAvLyBXZSBkbyBub3QgbmVlZCB0byBzdG9yZSB0aGUgd2hvbGUgbWF0cml4OiB3ZSBqdXN0IG5lZWQgdGhlIGN1cnJlbnQgYW5kXG4gIC8vIHByZXZpb3VzIHJvd3MuXG4gIGxldCBvbGREaXN0OiBudW1iZXJbXSA9IEFycmF5KHlMZW4gKyAxKTtcbiAgbGV0IGN1ckRpc3Q6IG51bWJlcltdID0gQXJyYXkoeUxlbiArIDEpO1xuXG4gIC8vIEZpbGwgdGhlIGZpcnN0IHJvd1xuICBmb3IgKGxldCBjb2w6IG51bWJlciA9IDA7IGNvbCA8PSB5TGVuOyBjb2wrKykge1xuICAgIGN1ckRpc3RbY29sXSA9IGNvbDtcbiAgfVxuXG4gIC8vIFRyYXZlcnNlIHhTZXFcbiAgZm9yIChsZXQgcm93OiBudW1iZXIgPSAxOyByb3cgPD0geExlbjsgcm93KyspIHtcbiAgICBbY3VyRGlzdCwgb2xkRGlzdF0gPSBbb2xkRGlzdCwgY3VyRGlzdF07XG5cbiAgICBjb25zdCByb3dJdGVtOiBUID0gc3JjLmdldEl0ZW0ocm93IC0gMSk7XG5cbiAgICAvLyBJbml0aWFsaXplIGZpcnN0IGNvbHVtblxuICAgIGN1ckRpc3RbMF0gPSByb3c7XG5cbiAgICAvLyBDb21wdXRlIGRpc3RhbmNlc1xuICAgIGZvciAobGV0IGNvbDogbnVtYmVyID0gMTsgY29sIDw9IHlMZW47IGNvbCsrKSB7XG4gICAgICAvLyBOZWFyZXN0IGRpc3RhbmNlIGluIGNhc2Ugb2YgQUREIG9yIERFTFxuICAgICAgY29uc3QgYWRkRGVsRGlzdDogbnVtYmVyID0gTWF0aC5taW4ob2xkRGlzdFtjb2xdLCBjdXJEaXN0W2NvbCAtIDFdKSArIDE7XG4gICAgICAvLyBOZWFyZXN0IGRpc3RhbmNlIGluIGNhc2Ugb2YgTUFUQ0hcbiAgICAgIGNvbnN0IG1hdGNoRGlzdDogbnVtYmVyID0gb2xkRGlzdFtjb2wgLSAxXTtcbiAgICAgIC8vIE5lYXJlc3QgZGlzdGFuY2UgaW4gY2FzZSBvZiBNVVRcbiAgICAgIGNvbnN0IG11dERpc3Q6IG51bWJlciA9IG1hdGNoRGlzdCArIDE7XG5cbiAgICAgIGlmIChhZGREZWxEaXN0IDw9IG1hdGNoRGlzdCkge1xuICAgICAgICAvLyBTZWUgdGhlIGNvbW1lbnQgYWJvdmUgYWJvdXQgc2tpcHBpbmcgdGhlIHRlc3QgYGNvbEl0ZW0gPT09IHJvd0l0ZW1gXG4gICAgICAgIGN1ckRpc3RbY29sXSA9IGFkZERlbERpc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2xJdGVtOiBUID0gdGFyZ2V0LmdldEl0ZW0oY29sIC0gMSk7XG4gICAgICAgIGN1ckRpc3RbY29sXSA9IGNvbEl0ZW0gPT09IHJvd0l0ZW0gPyBtYXRjaERpc3QgOiBtdXREaXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFNlYXJjaCBmb3IgbWluaW11bSBpbiB0aGUgbGFzdCBsaW5lXG4gIGxldCBtaW5EaXN0Q29sOiBudW1iZXIgPSAwO1xuICBmb3IgKGxldCBjb2w6IG51bWJlciA9IDE7IGNvbCA8PSB5TGVuOyBjb2wrKykge1xuICAgIC8vIFdlIHVzZSBlcXVhbGl0eSB0byBnZXQgdGhlIHJpZ2h0bW9zdCBtaW5pbWFsIHZhbHVlLlxuICAgIGlmIChjdXJEaXN0W2NvbF0gPD0gY3VyRGlzdFttaW5EaXN0Q29sXSkge1xuICAgICAgbWluRGlzdENvbCA9IGNvbDtcbiAgICB9XG4gIH1cblxuICBjb25zdCBtaW5EaXN0SW5kZXg6IG51bWJlciA9IG1pbkRpc3RDb2wgLSAxO1xuICBjb25zdCBtaW5EaXN0VmFsdWU6IG51bWJlciA9IGN1ckRpc3RbbWluRGlzdENvbF07XG4gIHJldHVybiBbbWluRGlzdEluZGV4LCBtaW5EaXN0VmFsdWVdO1xufVxuXG5mdW5jdGlvbiBoaXJzY2hiZXJnKHNvdXJjZTogU2xpY2U8YW55PiwgdGFyZ2V0OiBTbGljZTxhbnk+KTogRGlmZkFjdGlvbltdIHtcbiAgY29uc3Qgc3JjTGVuOiBudW1iZXIgPSBzb3VyY2UubGVuZ3RoO1xuICBjb25zdCB0YXJMZW46IG51bWJlciA9IHRhcmdldC5sZW5ndGg7XG5cbiAgaWYgKHNyY0xlbiA9PT0gMCB8fCB0YXJMZW4gPT09IDApIHtcbiAgICBpZiAoc3JjTGVuID4gMCkge1xuICAgICAgcmV0dXJuIFt7dHlwZTogXCJzb3VyY2VcIiwgdmFsdWU6IHNyY0xlbn1dO1xuICAgIH0gZWxzZSBpZiAodGFyTGVuID4gMCkge1xuICAgICAgcmV0dXJuIFt7dHlwZTogXCJ0YXJnZXRcIiwgdmFsdWU6IHRhckxlbn1dO1xuICAgIH0gZWxzZSB7ICAvLyBzcmNMZW4gPT09IDAgJiYgdGFyTGVuID09PSAwXG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9IGVsc2UgaWYgKHNyY0xlbiA9PT0gMSB8fCB0YXJMZW4gPT09IDEpIHtcbiAgICBsZXQgaWR4OiBudW1iZXIgPSBzb3VyY2UuaW5kZXhPZih0YXJnZXQuZ2V0SXRlbSgwKSk7XG4gICAgaWYgKHNyY0xlbiA+IDEgJiYgaWR4ID49IDApIHtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHt0eXBlOiBcInNvdXJjZVwiLCB2YWx1ZTogaWR4fSxcbiAgICAgICAge3R5cGU6IFwibWF0Y2hcIiwgdmFsdWU6IDF9LFxuICAgICAgICB7dHlwZTogXCJzb3VyY2VcIiwgdmFsdWU6IHNyY0xlbiAtIGlkeCAtIDF9LFxuICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWR4ID0gdGFyZ2V0LmluZGV4T2Yoc291cmNlLmdldEl0ZW0oMCkpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAge3R5cGU6IFwidGFyZ2V0XCIsIHZhbHVlOiBpZHh9LFxuICAgICAgICAgIHt0eXBlOiBcIm1hdGNoXCIsIHZhbHVlOiAxfSxcbiAgICAgICAgICB7dHlwZTogXCJ0YXJnZXRcIiwgdmFsdWU6IHRhckxlbiAtIGlkeCAtIDF9LFxuICAgICAgICBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICB7dHlwZTogXCJzb3VyY2VcIiwgdmFsdWU6IHNyY0xlbn0sXG4gICAgICAgICAge3R5cGU6IFwidGFyZ2V0XCIsIHZhbHVlOiB0YXJMZW59LFxuICAgICAgICBdO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzcmNNaWQ6IG51bWJlciA9IE1hdGguZmxvb3Ioc3JjTGVuIC8gMik7XG4gICAgY29uc3QgW3NyY0xlZnQsIHNyY1JpZ2h0XTogW1NsaWNlPGFueT4sIFNsaWNlPGFueT5dID0gc291cmNlLnNwbGl0KHNyY01pZCk7XG4gICAgY29uc3QgW2xlZnRNaW5EaXN0SWR4LCBsZWZ0TWluVmFsXTogW251bWJlciwgbnVtYmVyXSA9IG5lYXJlc3RFbmQoc3JjTGVmdCwgdGFyZ2V0KTtcbiAgICBjb25zdCBbcmlnaHRNaW5EaXN0SWR4LCByaWdodE1pblZhbF06IFtudW1iZXIsIG51bWJlcl0gPSBuZWFyZXN0RW5kKHNyY1JpZ2h0LnJldmVyc2UoKSwgdGFyZ2V0LnJldmVyc2UoKSk7XG4gICAgbGV0IHRhcmdldE1pZDogbnVtYmVyO1xuICAgIGlmIChsZWZ0TWluVmFsIDw9IHJpZ2h0TWluVmFsKSB7XG4gICAgICAvLyBXZSBhZGQgb25lIGJlY2F1c2UgdGhlIHJpZ2h0IG9mIHRoZSByYW5nZSBpcyBleGNsdXNpdmVcbiAgICAgIHRhcmdldE1pZCA9IGxlZnRNaW5EaXN0SWR4ICsgMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udmVydCB0aGUgcmlnaHQgaW5kZXggZnJvbSB0aGUgcmV2ZXJzZWQgdGFyUmlnaHQgdG8gdGFyZ2V0XG4gICAgICB0YXJnZXRNaWQgPSAodGFyZ2V0Lmxlbmd0aCAtIDEpIC0gcmlnaHRNaW5EaXN0SWR4O1xuICAgIH1cbiAgICBjb25zdCBbdGFyTGVmdCwgdGFyUmlnaHRdOiBbU2xpY2U8YW55PiwgU2xpY2U8YW55Pl0gPSB0YXJnZXQuc3BsaXQodGFyZ2V0TWlkKTtcbiAgICBjb25zdCBsZWZ0OiBEaWZmQWN0aW9uW10gPSBoaXJzY2hiZXJnKHNyY0xlZnQsIHRhckxlZnQpO1xuICAgIGNvbnN0IHJpZ2h0OiBEaWZmQWN0aW9uW10gPSBoaXJzY2hiZXJnKHNyY1JpZ2h0LCB0YXJSaWdodCk7XG4gICAgcmV0dXJuIFsuLi5sZWZ0LCAuLi5yaWdodF07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZURpZmYoZGlmZjogRGlmZkFjdGlvbltdKTogRGlmZkFjdGlvbltdIHtcbiAgY29uc3QgcmVzdWx0OiBEaWZmQWN0aW9uW10gPSBbXTtcbiAgaWYgKGRpZmYubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZXQgY3VyU291cmNlOiBudW1iZXIgPSAwO1xuICBsZXQgY3VyVGFyZ2V0OiBudW1iZXIgPSAwO1xuICBsZXQgY3VyQm90aDogbnVtYmVyID0gMDtcbiAgZm9yIChjb25zdCBhY3Rpb24gb2YgZGlmZikge1xuICAgIGlmIChhY3Rpb24udmFsdWUgPT09IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChhY3Rpb24udHlwZSA9PT0gXCJtYXRjaFwiKSB7XG4gICAgICBpZiAoY3VyU291cmNlID4gMCkge1xuICAgICAgICByZXN1bHQucHVzaCh7dHlwZTogXCJzb3VyY2VcIiwgdmFsdWU6IGN1clNvdXJjZX0pO1xuICAgICAgICBjdXJTb3VyY2UgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGN1clRhcmdldCA+IDApIHtcbiAgICAgICAgcmVzdWx0LnB1c2goe3R5cGU6IFwidGFyZ2V0XCIsIHZhbHVlOiBjdXJUYXJnZXR9KTtcbiAgICAgICAgY3VyVGFyZ2V0ID0gMDtcbiAgICAgIH1cbiAgICAgIGN1ckJvdGggKz0gYWN0aW9uLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoY3VyQm90aCA+IDApIHtcbiAgICAgICAgcmVzdWx0LnB1c2goe3R5cGU6IFwibWF0Y2hcIiwgdmFsdWU6IGN1ckJvdGh9KTtcbiAgICAgICAgY3VyQm90aCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAoYWN0aW9uLnR5cGUgPT09IFwic291cmNlXCIpIHtcbiAgICAgICAgY3VyU291cmNlICs9IGFjdGlvbi52YWx1ZTtcbiAgICAgIH0gZWxzZSB7IC8vIGFjdGlvbi50eXBlID09PSBcInRhcmdldFwiXG4gICAgICAgIGN1clRhcmdldCArPSBhY3Rpb24udmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChjdXJTb3VyY2UgPiAwKSB7XG4gICAgcmVzdWx0LnB1c2goe3R5cGU6IFwic291cmNlXCIsIHZhbHVlOiBjdXJTb3VyY2V9KTtcbiAgfVxuICBpZiAoY3VyVGFyZ2V0ID4gMCkge1xuICAgIHJlc3VsdC5wdXNoKHt0eXBlOiBcInRhcmdldFwiLCB2YWx1ZTogY3VyVGFyZ2V0fSk7XG4gIH1cbiAgaWYgKGN1ckJvdGggPiAwKSB7XG4gICAgcmVzdWx0LnB1c2goe3R5cGU6IFwibWF0Y2hcIiwgdmFsdWU6IGN1ckJvdGh9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGlmZlN5bmMoc2VxMTogc3RyaW5nIHwgYW55W10sIHNlcTI6IHN0cmluZyB8IGFueVtdKTogRGlmZkFjdGlvbltdIHtcbiAgcmV0dXJuIG5vcm1hbGl6ZURpZmYoaGlyc2NoYmVyZyhuZXcgU2xpY2Uoc2VxMSwgMCwgc2VxMS5sZW5ndGgsIGZhbHNlKSwgbmV3IFNsaWNlKHNlcTIsIDAsIHNlcTIubGVuZ3RoLCBmYWxzZSkpKTtcbn1cblxuLypcbiAqIFN0cnVjdHVyZSBvZiB0aGUgTGV2ZW5zaHRlaW4gbWF0cml4XG4gKlxuICogTGV0J3Mgc2VlIHdoaWNoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBncmlkIHdlIGNhbiBnZXQgZnJvbSB0aGUgZXF1YXRpb25cbiAqIG9mIGByYC5cbiAqIEJ5IGRlZmluaXRpb24gb2YgYG1pbmAsIHdlIGhhdmU6XG4gKlxuICogYGBgXG4gKiDilLzilIDilLzilIDilLxcbiAqIOKUgm3ilIJh4pSCICAgciA8PSBtICsgMSAgKFRoaXMgaXMgdHJ1ZSBpbmRlcGVuZGVudGx5IG9mIGBpc01hdGNoYCkgICAgICAgIFtlcS4gMDNdXG4gKiDilLzilIDilLzilIDilLwgICByIDw9IGEgKyAxICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2VxLiAwNF1cbiAqIOKUgmTilIJy4pSCICAgciA8PSBkICsgMSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtlcS4gMDVdXG4gKiDilLzilIDilLzilIDilLxcbiAqIGBgYFxuICpcbiAqIFRoaXMgbWVhbnMgdGhhdCBncm93dGggb2YgdGhlIGRpc3RhbmNlIHdoZW4gd2UgZ28gdG8gdGhlIHJpZ2h0IG9yIGRvd24gaXNcbiAqIGJvdW5kZWQuIFlvdSBjYW5ub3QgaW5jcmVhc2Ugb2YgbW9yZSB0aGFuIDEgd2hlbiBnb2luZyB0byB0aGUgcmlnaHQgb3IgZG93bi5cbiAqXG4gKiBJdCBtZWFucyB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZmlndXJhdGlvbnMgYXJlIGltcG9zc2libGU6XG4gKlxuICogYGBgXG4gKiDilLzilIDilLzilIDilLxcbiAqIOKUgjXilIIg4pSCICAgSU1QT1NTSUJMRSwgYnJlYWtzOiByIDw9IG0gKyAxXG4gKiDilLzilIDilLzilIDilLxcbiAqIOKUgiDilII34pSCXG4gKiDilLzilIDilLzilIDilLxcbiAqXG4gKiDilLzilIDilLzilIDilLxcbiAqIOKUgiDilII14pSCICAgSU1QT1NTSUJMRSwgYnJlYWtzOiByIDw9IGEgKyAxXG4gKiDilLzilIDilLzilIDilLxcbiAqIOKUgiDilII34pSCXG4gKiDilLzilIDilLzilIDilLxcbiAqXG4gKiDilLzilIDilLzilIDilLxcbiAqIOKUgiDilIIg4pSCICAgSU1QT1NTSUJMRSwgYnJlYWtzOiByIDw9IGQgKyAxXG4gKiDilLzilIDilLzilIDilLxcbiAqIOKUgjXilII34pSCXG4gKiDilLzilIDilLzilIDilLxcbiAqIGBgYFxuICpcbiAqIFNpbmNlIHRoZXNlIGluZXF1YWxpdGllcyBhcmUgcmVsYXRpdmUgdG8gYSBgcmAsIHdlIGNhbiB0cmFuc2xhdGUgdGhlbTpcbiAqIGBgYFxuICog4pS84pSA4pS84pSA4pS8XG4gKiDilIJt4pSCYeKUgiAgIGQgPD0gbSArIDEgICAoZnJvbSBbZXEuIDRdKSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZXEuIDA2XVxuICog4pS84pSA4pS84pSA4pS8ICAgYSA8PSBtICsgMSAgIChmcm9tIFtlcS4gNV0pICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtlcS4gMDddXG4gKiDilIJk4pSCcuKUglxuICog4pS84pSA4pS84pSA4pS8XG4gKiBgYGBcbiAqXG4gKiBXZSBjYW4gYWxzbyBhZGQgYSBsb3dlciBib3VuZCB0byB0aGUgZ3Jvd3RoIHdoZW4gZ29pbmcgdG8gdGhlIHJpZ2h0IG9yIGRvd246XG4gKiBgYGBcbiAqIGEgLSAxIDw9IHIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtlcS4gMDhdXG4gKiBkIC0gMSA8PSByICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbZXEuIDA5XVxuICogYGBgXG4gKiBTbyBgcmAgY2Fubm90IGdyb3cgZmFzdGVyIHRoYW4gYDFgIHBlciBjZWxsLCBidXQgYWxzbyBjYW5ub3QgZGVjcmVhc2UgZmFzdGVyLlxuICpcbiAqIFRoaXMgbWVhbnMgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmZpZ3VyYXRpb24gYXJlIGltcG9zc2libGU6XG4gKlxuICogYGBgXG4gKiDilLzilIDilLzilIDilLxcbiAqIOKUgiDilII34pSCICAgSU1QT1NTSUJMRSwgYnJlYWtzOiBhIC0gMSA8PSByXG4gKiDilLzilIDilLzilIDilLxcbiAqIOKUgiDilII14pSCXG4gKiDilLzilIDilLzilIDilLxcbiAqXG4gKiDilLzilIDilLzilIDilLxcbiAqIOKUgiDilIIg4pSCICAgSU1QT1NTSUJMRSwgYnJlYWtzOiBkIC0gMSA8PSByXG4gKiDilLzilIDilLzilIDilLxcbiAqIOKUgjfilII14pSCXG4gKiDilLzilIDilLzilIDilLxcbiAqIGBgYFxuICpcbiAqIFdlIHdpbGwgb25seSBwcm92ZSB0aGUgZmlyc3QgaW5lcXVhbGl0eSBgYSAtIDEgPD0gcmAgc2luY2UgYm90aCBpbmVxdWFsaXRpZXNcbiAqIGFyZSBpbiBmYWN0IGVxdWl2YWxlbnQgZHVlIHRvIHRoZSBzeW1tZXRyeSBvZiB0aGUgcHJvYmxlbS5cbiAqXG4gKiBUbyBkZW1vbnN0cmF0ZSBpdCwgd2UnbGwgdXNlIGEgcHJvb2YgYnkgY29udHJhZGljdGlvbjogd2Ugd2lsbCBzaG93IHRoYXQgaXRcbiAqIHNpbXBseSBjYW5ub3QgYmUgb3RoZXJ3aXNlLlxuICogVGhlIG9wcG9zaXRlIG9mIGBhIC0gMSA8PSByYCBpczpcbiAqIGBgYFxuICogYSAtIDEgPiByICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2VxLiAxMF1cbiAqIGBgYFxuICogVGhpcyBpbmVxdWFsaXR5IGlzIGluY29tcGF0aWJsZSB3aXRoIHRoZSB2YWx1ZSBvZiBgcmAgd2hldGhlciBpdCBjb21lcyBmcm9tXG4gKiBhIE1BVENILCBNVVQsIEFERCBvciBERUw6XG4gKlxuICpcbiAqIE1BVENIOlxuICogYGBgXG4gKiByID0gbSAgICAgICAgICAgICAgKGRlZmluaXRpb24gb2YgTUFUQ0gpXG4gKiBhIC0gMSA+IHIgICAgICAgICAgKGh5cG90aGVzaXMpXG4gKiBhIDw9IG0gKyAxICAgICAgICAgKHByZXZpb3VzIGNvbnN0cmFpbnQgW2VxLiAwN10pXG4gKiBgYGBcbiAqIFdlIGNhbiB0cmFuc2Zvcm0gaXQ6XG4gKiBgYGBcbiAqIHIgPSBtXG4gKiBhID4gciArIDEgICAgICAgICAgKG1vdmUgYC0xYCB0byB0aGUgcmlnaHQgc2lkZSlcbiAqIGEgPD0gciArIDEgICAgICAgICAoc3Vic3RpdHV0ZSBgbWAgZm9yIGByYClcbiAqIGBgYFxuICogVGhpcyBzeXN0ZW0gZG9lcyBub3QgaGF2ZSBhbnkgc29sdXRpb24uXG4gKlxuICogTVVUOlxuICogYGBgXG4gKiByID0gbSArIDEgICAgICAgICAgKGRlZmluaXRpb24gb2YgTVVUKVxuICogYSAtIDEgPiByICAgICAgICAgIChoeXBvdGhlc2lzKVxuICogYSA8PSBtICsgMSAgICAgICAgIChwcmV2aW91cyBjb25zdHJhaW50IFtlcS4gMDddKVxuICogYGBgXG4gKiBXZSBjYW4gdHJhbnNmb3JtIGl0OlxuICogYGBgXG4gKiByID0gbVxuICogYSA+IHIgKyAxICAgICAgICAgIChtb3ZlIGAtMWAgdG8gdGhlIHJpZ2h0IHNpZGUpXG4gKiBhIDw9IHIgICAgICAgICAgICAgKHN1YnN0aXR1dGUgYG0gKyAxYCBmb3IgYHJgKVxuICogYGBgXG4gKiBUaGlzIHN5c3RlbSBkb2VzIG5vdCBoYXZlIGFueSBzb2x1dGlvbi5cbiAqXG4gKlxuICogQUREOlxuICogYGBgXG4gKiByID0gYSArIDEgICAgICAgICAgKGRlZmluaXRpb24gb2YgQUREKVxuICogYSAtIDEgPiByICAgICAgICAgIChoeXBvdGhlc2lzKVxuICogYGBgXG4gKiBUaGlzIHN5c3RlbSBkb2VzIG5vdCBoYXZlIGFueSBzb2x1dGlvbi5cbiAqXG4gKlxuICogREVMOlxuICogU28gZmFyIHdlJ3ZlIHNlZW4gdGhhdCB0aGUgTUFUQ0gsIE1VVCBhbmQgQUREIGZvciBgcmAgYXJlIGluY29tcGF0aWJsZVxuICogd2l0aCBgYSAtIDEgPiByYC4gTGV0J3MgY2hlY2sgdGhlIGxhc3QgY2FzZTogREVMLlxuICpcbiAqIGBgYFxuICogciA9IGQgKyAxICAgICAgICAgIChkZWZpbml0aW9uIG9mIERFTClcbiAqIGEgLSAxID4gciAgICAgICAgICAoaHlwb3RoZXNpcylcbiAqIGEgPD0gbSArIDEgICAgICAgICAocHJldmlvdXMgY29uc3RyYWludClcbiAqIGBgYFxuICogV2UgY2FuIHRyYW5zZm9ybSBpdDpcbiAqIGBgYFxuICogciAtIDEgPSBkICAgICAgICAgIChtb3ZlIGAxYCB0byB0aGUgbGVmdClcbiAqIGEgPiByICsgMSAgICAgICAgICAobW92ZSBgLTFgIHRvIHRoZSByaWdodClcbiAqIG0gKyAxID49IGEgICAgICAgICAoc3dhcClcbiAqIGBgYFxuICogQW5kIGFnYWluOlxuICogYGBgXG4gKiBkID0gciAtIDEgICAgICAgICAgKHN3YXApXG4gKiBhID4gciArIDFcbiAqIG0gKyAxID49IGFcbiAqIG0gKyAxID4gciArIDEgICAgICAodHJhbnNpdGl2aXR5IHdpdGggbGluZSAyIGFuZCAzOiBtICsgMSA+PSBhID4gciArIDEpXG4gKiBgYGBcbiAqIEFuZCBhZ2FpbjpcbiAqIGBgYFxuICogZCA9IHIgLSAxICAgICAgICAgIChzd2FwKVxuICogYSA+IHIgKyAxXG4gKiBtICsgMSA+PSBhXG4gKiBtID4gciAgICAgICAgICAgICAgKGNhbmNlbCBgMWApXG4gKiBgYGBcbiAqIEFuZCBhZ2FpbjpcbiAqIGBgYFxuICogZCA9IHIgLSAxXG4gKiBhID4gciArIDFcbiAqIG0gKyAxID49IGFcbiAqIG0gPiBkICsgMSAgICAgICAgICAoU3Vic3RpdHV0ZSBgcmAgZm9yIGBkKzFgKVxuICogYGBgXG4gKiBXZSBjYW4gcGxhY2UgdGhlc2UgZXF1YXRpb25zIG9uIHRoZSBncmlkIHRvIGJldHRlciB2aXN1YWxpemUgdGhlIHNpdHVhdGlvbi5cbiAqIGBgYFxuICog4pS84pSA4pSA4pSA4pSA4pSA4pS84pSA4pSA4pSA4pSA4pSA4pS8XG4gKiDilII+IGQrMeKUgj4gcisx4pSCXG4gKiDilLzilIDilIDilIDilIDilIDilLzilIDilIDilIDilIDilIDilLxcbiAqIOKUgiAgZCAg4pSCICByICDilIJcbiAqIOKUvOKUgOKUgOKUgOKUgOKUgOKUvOKUgOKUgOKUgOKUgOKUgOKUvFxuICpcbiAqIGBgYFxuICpcbiAqIElmIHdlIHJlY2FwIHdoYXQgd2Uga25vdzpcbiAqXG4gKiBUaGUgY2VsbCBhYm92ZSBgcmAgY2FuIGhhdmUgYSB2YWx1ZSAoc3RyaWN0bHkpIGdyZWF0ZXIgdGhhbiBgciArIDFgXG4gKiBJRlxuICogVGhlIGNlbGwgYWJvdmUgYGRgIGhhcyBhIHZhbHVlIChzdHJpY3RseSkgZ3JlYXRlciB0aGFuIGBkICsgMWAuXG4gKlxuICogU28gdG8gaGF2ZSBhIGRlY3JlYXNlIG9mIDIgb3IgbW9yZSBiZXR3ZWVuIG9uZSBjZWxsIGFuZCB0aGUgY2VsbCBiZWxvdywgd2VcbiAqIGhhdmUgdG8gaGF2ZSBhIGRlY3JlYXNlIG9mIDIgb3IgbW9yZSBvbiB0aGUgY29sdW1uIHRvIHRoZSBsZWZ0LlxuICogUmVjdXJzaXZlbHksIHRvIGhhdmUgYSBkZWNyZWFzZSBvZiAyIG9yIG1vcmUgb24gdGhlIGNvbHVtbiBgai0xYCwgd2UgbmVlZFxuICogdGhpcyBkZWNyZWFzZSBvbiBgai0yYCBzbyBhbHNvIG9uIGBqLTNgIGFuZCBhbHNvIG9uIGBqLTRgIGFuZCBzbyBvbiB1bnRpbCB3ZVxuICogcmVhY2ggdGhlIGxlZnRtb3N0IGNvbHVtbi4uLlxuICpcbiAqID4gVGhlIHRvcCByb3cgaXMgaW5pdGlhbGl6ZWQgd2l0aCBpbnRlZ2VycyBmcm9tIDAgdG8gYG5gLCB0aGUgbGVmdCBjb2x1bW5cbiAqID4gd2l0aCBpbnRlZ2VycyBmcm9tIDAgdG8gYG1gLlxuICpcbiAqIFRoZSBsZWZ0bW9zdCBjb2x1bW4gaXMgc3RyaWN0bHkgaW5jcmVhc2luZyBzbyBpdCBkb2VzIG5vdCBjb250YWluIGFueVxuICogZGVjcmVhc2Ugb2YgdHdvIG9yIG1vcmUuIFRoaXMgbWVhbnMgdGhhdCB0aGUgcGF0dGVybiBkZXNjcmliZWQgYWJvdmUgaXNcbiAqIGltcG9zc2libGUgYW5kIGBhIC0gMSA+IHJgIGlzIG5vdCBwb3NzaWJsZSB3aXRoIGEgREVMIG9wZXJhdGlvbi5cbiAqXG4gKiBgYSAtIDEgPiByYCBpcyBub3QgcG9zc2libGUgd2l0aCBhbnkgb3BlcmF0aW9uLCBpdCBpcyBhbHdheXMgZmFsc2UuXG4gKiBTbywgaXRzIG9wcG9zaXRlIGBhIC0gMSA8PSByYCBpcyBhbHdheXMgdHJ1ZS4gT3Igd2UgY291bGQganVzdCBoYXZlIHNhaWQgdGhhdFxuICogdGhlIHByb2JsZW0gaXMgc3ltbWV0cmljIGlmIHdlIHJldmVyc2UgYm90aCBzdHJpbmdzLlxuICovXG4iXSwic291cmNlUm9vdCI6Ii4uIn0=
