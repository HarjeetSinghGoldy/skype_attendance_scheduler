import { createInvalidFloat64Error } from "../errors/invalid-float64";
import { createInvalidTypeError } from "../errors/invalid-type";
import { name as typeName } from "../types/float64";
function write(type, value) {
    if (isNaN(value)) {
        return "NaN";
    }
    else if (value === Infinity) {
        return "+Infinity";
    }
    else if (value === -Infinity) {
        return "-Infinity";
    }
    return value.toString(10);
}
function read(type, input) {
    if (typeof input !== "string") {
        throw createInvalidTypeError("string", input);
    }
    switch (input) {
        case "NaN":
            if (!type.allowNaN) {
                throw createInvalidFloat64Error(input);
            }
            return NaN;
        case "+Infinity":
            if (!type.allowInfinity) {
                throw createInvalidFloat64Error(input);
            }
            return Infinity;
        case "-Infinity":
            if (!type.allowInfinity) {
                throw createInvalidFloat64Error(input);
            }
            return -Infinity;
        default:
            const val = parseFloat(input);
            const error = type.testError(val);
            if (error !== undefined) {
                throw error;
            }
            return val;
    }
}
function readTrusted(type, input) {
    switch (input) {
        case "NaN":
            return NaN;
        case "+Infinity":
            return Infinity;
        case "-Infinity":
            return -Infinity;
        default:
            return parseFloat(input);
    }
}
export const SERIALIZER = {
    typeName,
    write,
    read,
    readTrusted,
};
export function register(serializer) {
    serializer.register(SERIALIZER);
}
