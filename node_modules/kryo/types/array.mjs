import { lazyProperties } from "../_helpers/lazy-properties";
import { createInvalidArrayItemsError } from "../errors/invalid-array-items";
import { createInvalidTypeError } from "../errors/invalid-type";
import { createLazyOptionsError } from "../errors/lazy-options";
import { createMaxArrayLengthError } from "../errors/max-array-length";
import { createNotImplementedError } from "../errors/not-implemented";
import { JSON_SERIALIZER } from "../json";
export const name = "array";
// tslint:disable-next-line:variable-name
export const ArrayType = class {
    constructor(options) {
        this.name = name;
        // TODO: Remove once TS 2.7 is better supported by editors
        this.itemType = undefined;
        this.maxLength = undefined;
        this._options = options;
        if (typeof options !== "function") {
            this._applyOptions();
        }
        else {
            lazyProperties(this, this._applyOptions, ["itemType", "maxLength"]);
        }
    }
    toJSON() {
        throw createNotImplementedError("ArrayType#toJSON");
    }
    readTrustedJson(input) {
        return input.map((item) => JSON_SERIALIZER.readTrusted(this.itemType, item));
    }
    readJson(input) {
        if (!Array.isArray(input)) {
            throw createInvalidTypeError("array", input);
        }
        if (this.maxLength !== undefined && input.length > this.maxLength) {
            throw createMaxArrayLengthError(input, this.maxLength);
        }
        let invalid = undefined;
        const result = [];
        const itemCount = input.length;
        for (let i = 0; i < itemCount; i++) {
            try {
                const item = JSON_SERIALIZER.read(this.itemType, input[i]);
                if (invalid === undefined) {
                    result.push(item);
                }
            }
            catch (err) {
                if (invalid === undefined) {
                    invalid = new Map();
                }
                invalid.set(i, err);
            }
        }
        if (invalid !== undefined) {
            throw createInvalidArrayItemsError(invalid);
        }
        return result;
    }
    writeJson(val) {
        return val.map((item) => JSON_SERIALIZER.write(this.itemType, item));
    }
    testError(val) {
        if (!Array.isArray(val)) {
            return createInvalidTypeError("array", val);
        }
        if (this.maxLength !== undefined && val.length > this.maxLength) {
            return createMaxArrayLengthError(val, this.maxLength);
        }
        const invalid = new Map();
        const itemCount = val.length;
        for (let i = 0; i < itemCount; i++) {
            const error = this.itemType.testError(val[i]);
            if (error !== undefined) {
                invalid.set(i, error);
            }
        }
        if (invalid.size !== 0) {
            return createInvalidArrayItemsError(invalid);
        }
        return undefined;
    }
    test(val) {
        if (!Array.isArray(val) || (this.maxLength !== undefined && val.length > this.maxLength)) {
            return false;
        }
        for (const item of val) {
            if (!this.itemType.test(item)) {
                return false;
            }
        }
        return true;
    }
    equals(val1, val2) {
        if (val2.length !== val1.length) {
            return false;
        }
        for (let i = 0; i < val1.length; i++) {
            if (!this.itemType.equals(val2[i], val1[i])) {
                return false;
            }
        }
        return true;
    }
    clone(val) {
        return val.map((item) => this.itemType.clone(item));
    }
    /**
     * @param oldVal
     * @param newVal
     * @returns `true` if there is a difference, `undefined` otherwise
     */
    diff(oldVal, newVal) {
        throw createNotImplementedError("ArrayType#diff");
    }
    patch(oldVal, diff) {
        throw createNotImplementedError("ArrayType#patch");
    }
    reverseDiff(diff) {
        throw createNotImplementedError("ArrayType#reverseDiff");
    }
    squash(diff1, diff2) {
        throw createNotImplementedError("ArrayType#squash");
    }
    _applyOptions() {
        if (this._options === undefined) {
            throw createLazyOptionsError(this);
        }
        const options = typeof this._options === "function" ? this._options() : this._options;
        const itemType = options.itemType;
        const maxLength = options.maxLength;
        Object.assign(this, { itemType, maxLength });
        Object.freeze(this);
    }
};
