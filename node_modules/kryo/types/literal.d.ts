import { Lazy, VersionedType } from "../types";
export declare type Name = "literal";
export declare const name: Name;
export declare namespace bson {
    type Input = any;
    type Output = any;
}
export declare namespace json {
    type Input = any;
    type Output = any;
    type Type = undefined;
}
export declare type Diff = any;
export interface LiteralTypeOptions<T, Output, Input extends Output, Diff> {
    type: VersionedType<any, Output, Input, Diff>;
    value: T;
}
/**
 * You may need to explicitly write the type or inference won't pick it.
 * For example, in the case of enum values, inference will pick the type of the enum instead of
 * the specific property you pass.
 *
 * @see https://github.com/Microsoft/TypeScript/issues/10195
 */
export declare class LiteralType<T> implements VersionedType<T, json.Input, json.Output, Diff> {
    readonly name: Name;
    readonly type: VersionedType<T, any, any, Diff>;
    readonly value: T;
    private _options;
    constructor(options: Lazy<LiteralTypeOptions<T, any, any, any>>);
    toJSON(): json.Type;
    readTrustedJson(input: json.Output): T;
    readJson(input: any): T;
    writeJson(val: T): json.Output;
    testError(val: T): Error | undefined;
    test(val: T): boolean;
    equals(val1: T, val2: T): boolean;
    clone(val: T): T;
    diff(oldVal: T, newVal: T): Diff | undefined;
    patch(oldVal: T, diff: Diff | undefined): T;
    reverseDiff(diff: Diff | undefined): Diff | undefined;
    squash(diff1: Diff | undefined, diff2: Diff | undefined): Diff | undefined;
    private _applyOptions();
}
