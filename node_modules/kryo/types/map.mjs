import { Incident } from "incident";
import { lazyProperties } from "../_helpers/lazy-properties";
import { createInvalidTypeError } from "../errors/invalid-type";
import { createLazyOptionsError } from "../errors/lazy-options";
import { createNotImplementedError } from "../errors/not-implemented";
export const name = "map";
export class MapType {
    constructor(options) {
        this.name = name;
        // TODO: Remove once TS 2.7 is better supported by editors
        this.keyType = undefined;
        this.valueType = undefined;
        this.maxSize = undefined;
        this.assumeStringKey = undefined;
        this._options = options;
        if (typeof options !== "function") {
            this._applyOptions();
        }
        else {
            lazyProperties(this, this._applyOptions, ["keyType", "valueType", "maxSize", "assumeStringKey"]);
        }
    }
    toJSON() {
        throw createNotImplementedError("MapType#toJSON");
    }
    readTrustedJson(input) {
        const result = new Map();
        for (const keyString in input) {
            const key = this.keyType.readTrustedJson(JSON.parse(keyString));
            const value = this.valueType.readTrustedJson(input[keyString]);
            result.set(key, value);
        }
        return result;
    }
    readJson(input) {
        if (typeof input !== "object" || input === null) {
            throw createInvalidTypeError("object", input);
        }
        const result = new Map();
        for (const keyString in input) {
            let rawKey;
            try {
                rawKey = JSON.parse(keyString);
            }
            catch (err) {
                throw err;
            }
            const key = this.keyType.readJson(rawKey);
            const value = this.valueType.readJson(input[keyString]);
            result.set(key, value);
        }
        const error = this.testError(result);
        if (error !== undefined) {
            throw error;
        }
        return result;
    }
    writeJson(val) {
        const result = {};
        for (const [key, value] of val) {
            const rawKey = this.keyType.writeJson(key);
            const keyString = JSON.stringify(rawKey);
            // TODO(demurgos): Check for duplicate keys
            result[keyString] = this.valueType.writeJson(value);
        }
        return result;
    }
    testError(val) {
        if (!(val instanceof Map)) {
            return createInvalidTypeError("Map", val);
        }
        for (const [key, value] of val) {
            // TODO: test keyType
            const keyError = this.keyType.testError(key);
            if (keyError !== undefined) {
                return new Incident("InvalidMapKey", { key, value }, "Invalid map entry: invalid key");
            }
            const valueError = this.valueType.testError(value);
            if (valueError !== undefined) {
                return new Incident("InvalidMapValue", { key, value }, "Invalid map entry: invalid value");
            }
        }
        return undefined;
    }
    test(val) {
        return this.testError(val) === undefined;
    }
    equals(val1, val2) {
        if (val2.size !== val1.size) {
            return false;
        }
        // TODO(demurgos): This test is brittle (order-sensitive) and involves unnecessary serialization.
        const val1Json = JSON.stringify(this.writeJson(val1));
        const val2Json = JSON.stringify(this.writeJson(val2));
        return val1Json === val2Json;
    }
    clone(val) {
        const result = new Map();
        for (const [key, value] of val) {
            const keyClone = this.keyType.clone(key);
            const valueClone = this.valueType.clone(value);
            result.set(key, value);
        }
        return result;
    }
    diff(oldVal, newVal) {
        throw createNotImplementedError("MapType#diff");
    }
    patch(oldVal, diff) {
        throw createNotImplementedError("MapType#patch");
    }
    reverseDiff(diff) {
        throw createNotImplementedError("MapType#reverseDiff");
    }
    squash(diff1, diff2) {
        throw createNotImplementedError("MapType#squash");
    }
    _applyOptions() {
        if (this._options === undefined) {
            throw createLazyOptionsError(this);
        }
        const options = typeof this._options === "function" ? this._options() : this._options;
        const keyType = options.keyType;
        const valueType = options.valueType;
        const maxSize = options.maxSize;
        const assumeStringKey = options.assumeStringKey || false;
        Object.assign(this, { keyType, valueType, maxSize, assumeStringKey });
        Object.freeze(this);
    }
}
