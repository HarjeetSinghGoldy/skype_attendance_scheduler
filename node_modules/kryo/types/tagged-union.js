"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
}
Object.defineProperty(exports, "__esModule", { value: true });
const incident_1 = require("incident");
const not_implemented_1 = require("../errors/not-implemented");
const literal_1 = require("./literal");
const simple_enum_1 = require("./simple-enum");
const union = __importStar(require("./union"));
exports.name = "tagged-union";
function getTagValuesWithBaseType(options) {
    const tagName = options.tag;
    let tagBaseType = undefined;
    const tagValuesMap = new Map();
    for (const variant of options.variants) {
        if (variant === undefined) {
            // tslint:disable-next-line:max-line-length
            throw new incident_1.Incident("UndefinedVariant", { variants: options.variants }, "The supplied TaggedUnion options contain undefined variants. If you have circular dependencies, try to use lazy options.");
        }
        if (!(tagName in variant.properties)) {
            throw new incident_1.Incident("TagNotFound", "Tag not found in variant of tagged union");
        }
        if (!(variant.properties[tagName].type instanceof literal_1.LiteralType)) {
            throw new incident_1.Incident("NonLiteralTag", "Tag property must be a literal type");
        }
        const curTag = variant.properties[tagName].type;
        if (tagBaseType === undefined) {
            // TODO: Use type name instead of instanceof
            if (curTag.type instanceof simple_enum_1.SimpleEnumType) {
                tagBaseType = curTag.type;
            }
            else {
                throw new incident_1.Incident("InvalidTagBaseType", "The base type of a tag property must be a simple enum");
            }
        }
        else if (curTag.type !== tagBaseType) {
            throw new incident_1.Incident("MixedTagBaseType", "All the variants of a tag property must have the same base type");
        }
        if (!(typeof curTag.value === "number" || typeof curTag.value === "string")) {
            throw new incident_1.Incident("InvalidTagValue", "The value of a tag property must be a number or string");
        }
        const value = curTag.value;
        if (tagValuesMap.has(value)) {
            throw new incident_1.Incident("DuplicateTagValue", "The tag values must be unique");
        }
        tagValuesMap.set(value, variant);
    }
    if (tagBaseType === undefined) {
        throw new incident_1.Incident("NoVariants");
    }
    return [tagValuesMap, tagBaseType];
}
/**
 * Create a map from the serialized label to the corresponding type variant
 *
 * @param tagName Name of the tag property
 * @param variants Type variants for this union, these should all be tagged document types
 * @param tagBaseType The underlying type of all the variants (must be a simple enum currently)
 * @param serializer The serializer to use to create the map
 * @return Map from the serialized label to the corresponding type variant.
 */
function createOutValuesMap(tagName, variants, tagBaseType, serializer) {
    const result = new Map();
    for (const variant of variants) {
        const curTag = variant.properties[tagName].type;
        const serialized = serializer.write(tagBaseType, curTag.value);
        if (!(typeof serialized === "number" || typeof serialized === "string")) {
            throw new incident_1.Incident("InvalidSerializedValue", { serialized });
        }
        if (result.has(serialized)) {
            throw new incident_1.Incident("DuplicateOutTagValue", "The serialized tag values must be unique");
        }
        result.set(serialized, variant);
    }
    return result;
}
function toUnionOptions(options) {
    const tagName = options.tag;
    // tslint:disable-next-line:max-line-length
    const [tagValuesMap, tagBaseType] = getTagValuesWithBaseType(options);
    const outValuesMaps = new WeakMap();
    const matcher = (value) => {
        if (typeof value !== "object" || value === null) {
            return undefined;
        }
        return tagValuesMap.get(value[tagName]);
    };
    const trustedMatcher = (value) => {
        return tagValuesMap.get(value[tagName]);
    };
    const readMatcher = (input, serializer) => {
        if (typeof input !== "object" || input === null) {
            return undefined;
        }
        let outValuesMap = outValuesMaps.get(serializer);
        if (outValuesMap === undefined) {
            outValuesMap = createOutValuesMap(tagName, options.variants, tagBaseType, serializer);
        }
        return outValuesMap.get(input[tagName]);
    };
    const readTrustedMatcher = (input, serializer) => {
        let outValuesMap = outValuesMaps.get(serializer);
        if (outValuesMap === undefined) {
            outValuesMap = createOutValuesMap(tagName, options.variants, tagBaseType, serializer);
        }
        return outValuesMap.get(input[tagName]);
    };
    return { variants: options.variants, matcher, trustedMatcher, readMatcher, readTrustedMatcher };
}
class TaggedUnionType extends union.UnionType {
    constructor(options) {
        super(typeof options === "function" ? () => toUnionOptions(options()) : toUnionOptions(options));
    }
    toJSON() {
        throw not_implemented_1.createNotImplementedError("TaggedUnionType#toJSON");
    }
    diff(oldVal, newVal) {
        throw not_implemented_1.createNotImplementedError("TaggedUnionType#diff");
    }
    patch(oldVal, diff) {
        throw not_implemented_1.createNotImplementedError("TaggedUnionType#patch");
    }
    reverseDiff(diff) {
        throw not_implemented_1.createNotImplementedError("TaggedUnionType#reverseDiff");
    }
    squash(diff1, diff2) {
        throw not_implemented_1.createNotImplementedError("TaggedUnionType#squash");
    }
}
exports.TaggedUnionType = TaggedUnionType;

//# sourceMappingURL=data:application/json;charset=utf8;base64,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TSwyQ0FBeUIsQ0FBQyw2QkFBNkIsQ0FBQyxDQUFDO0lBQ2pFLENBQUM7SUFFRCxNQUFNLENBQUMsS0FBdUIsRUFBRSxLQUF1QjtRQUNyRCxNQUFNLDJDQUF5QixDQUFDLHdCQUF3QixDQUFDLENBQUM7SUFDNUQsQ0FBQztDQUNGO0FBeEJELDBDQXdCQyIsImZpbGUiOiJ0eXBlcy90YWdnZWQtdW5pb24uanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmNpZGVudCB9IGZyb20gXCJpbmNpZGVudFwiO1xuaW1wb3J0IHsgY3JlYXRlTm90SW1wbGVtZW50ZWRFcnJvciB9IGZyb20gXCIuLi9lcnJvcnMvbm90LWltcGxlbWVudGVkXCI7XG5pbXBvcnQgeyBKc29uU2VyaWFsaXplciwgTGF6eSwgU2VyaWFsaXplciwgVHlwZSB9IGZyb20gXCIuLi90eXBlc1wiO1xuaW1wb3J0IHsgRG9jdW1lbnRUeXBlIH0gZnJvbSBcIi4vZG9jdW1lbnRcIjtcbmltcG9ydCB7IExpdGVyYWxUeXBlIH0gZnJvbSBcIi4vbGl0ZXJhbFwiO1xuaW1wb3J0IHsgU2ltcGxlRW51bVR5cGUgfSBmcm9tIFwiLi9zaW1wbGUtZW51bVwiO1xuaW1wb3J0ICogYXMgdW5pb24gZnJvbSBcIi4vdW5pb25cIjtcblxuZXhwb3J0IHR5cGUgTmFtZSA9IFwidGFnZ2VkLXVuaW9uXCI7XG5leHBvcnQgY29uc3QgbmFtZTogTmFtZSA9IFwidGFnZ2VkLXVuaW9uXCI7XG5leHBvcnQgbmFtZXNwYWNlIGpzb24ge1xuICBleHBvcnQgaW50ZXJmYWNlIElucHV0IHtcbiAgICBba2V5OiBzdHJpbmddOiBhbnk7XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIE91dHB1dCB7XG4gICAgW2tleTogc3RyaW5nXTogYW55O1xuICB9XG5cbiAgZXhwb3J0IHR5cGUgVHlwZSA9IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCB0eXBlIERpZmYgPSBhbnk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFnZ2VkVW5pb25UeXBlT3B0aW9uczxUIGV4dGVuZHMge30+IHtcbiAgdmFyaWFudHM6IERvY3VtZW50VHlwZTxUPltdO1xuICB0YWc6IGtleW9mIFQ7XG59XG5cbmZ1bmN0aW9uIGdldFRhZ1ZhbHVlc1dpdGhCYXNlVHlwZTxUIGV4dGVuZHMge30+KFxuICBvcHRpb25zOiBUYWdnZWRVbmlvblR5cGVPcHRpb25zPFQ+LFxuKTogW01hcDxudW1iZXIgfCBzdHJpbmcsIERvY3VtZW50VHlwZTxUPj4sIEpzb25TZXJpYWxpemVyPGFueSwgYW55LCBhbnk+XSB7XG4gIGNvbnN0IHRhZ05hbWU6IGtleW9mIFQgPSBvcHRpb25zLnRhZztcbiAgbGV0IHRhZ0Jhc2VUeXBlOiBKc29uU2VyaWFsaXplcjxhbnksIGFueSwgYW55PiB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgY29uc3QgdGFnVmFsdWVzTWFwOiBNYXA8bnVtYmVyIHwgc3RyaW5nLCBEb2N1bWVudFR5cGU8VD4+ID0gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IHZhcmlhbnQgb2Ygb3B0aW9ucy52YXJpYW50cykge1xuICAgIGlmICh2YXJpYW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgICAgIHRocm93IG5ldyBJbmNpZGVudChcIlVuZGVmaW5lZFZhcmlhbnRcIiwge3ZhcmlhbnRzOiBvcHRpb25zLnZhcmlhbnRzfSwgXCJUaGUgc3VwcGxpZWQgVGFnZ2VkVW5pb24gb3B0aW9ucyBjb250YWluIHVuZGVmaW5lZCB2YXJpYW50cy4gSWYgeW91IGhhdmUgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLCB0cnkgdG8gdXNlIGxhenkgb3B0aW9ucy5cIik7XG4gICAgfVxuXG4gICAgaWYgKCEodGFnTmFtZSBpbiB2YXJpYW50LnByb3BlcnRpZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW5jaWRlbnQoXCJUYWdOb3RGb3VuZFwiLCBcIlRhZyBub3QgZm91bmQgaW4gdmFyaWFudCBvZiB0YWdnZWQgdW5pb25cIik7XG4gICAgfVxuICAgIGlmICghKHZhcmlhbnQucHJvcGVydGllc1t0YWdOYW1lXS50eXBlIGluc3RhbmNlb2YgTGl0ZXJhbFR5cGUpKSB7XG4gICAgICB0aHJvdyBuZXcgSW5jaWRlbnQoXCJOb25MaXRlcmFsVGFnXCIsIFwiVGFnIHByb3BlcnR5IG11c3QgYmUgYSBsaXRlcmFsIHR5cGVcIik7XG4gICAgfVxuICAgIGNvbnN0IGN1clRhZzogTGl0ZXJhbFR5cGU8YW55PiA9IHZhcmlhbnQucHJvcGVydGllc1t0YWdOYW1lXS50eXBlIGFzIExpdGVyYWxUeXBlPGFueT47XG4gICAgaWYgKHRhZ0Jhc2VUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIFRPRE86IFVzZSB0eXBlIG5hbWUgaW5zdGVhZCBvZiBpbnN0YW5jZW9mXG4gICAgICBpZiAoY3VyVGFnLnR5cGUgaW5zdGFuY2VvZiBTaW1wbGVFbnVtVHlwZSkge1xuICAgICAgICB0YWdCYXNlVHlwZSA9IGN1clRhZy50eXBlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEluY2lkZW50KFwiSW52YWxpZFRhZ0Jhc2VUeXBlXCIsIFwiVGhlIGJhc2UgdHlwZSBvZiBhIHRhZyBwcm9wZXJ0eSBtdXN0IGJlIGEgc2ltcGxlIGVudW1cIik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjdXJUYWcudHlwZSAhPT0gdGFnQmFzZVR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBJbmNpZGVudChcIk1peGVkVGFnQmFzZVR5cGVcIiwgXCJBbGwgdGhlIHZhcmlhbnRzIG9mIGEgdGFnIHByb3BlcnR5IG11c3QgaGF2ZSB0aGUgc2FtZSBiYXNlIHR5cGVcIik7XG4gICAgfVxuICAgIGlmICghKHR5cGVvZiBjdXJUYWcudmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGN1clRhZy52YWx1ZSA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgIHRocm93IG5ldyBJbmNpZGVudChcIkludmFsaWRUYWdWYWx1ZVwiLCBcIlRoZSB2YWx1ZSBvZiBhIHRhZyBwcm9wZXJ0eSBtdXN0IGJlIGEgbnVtYmVyIG9yIHN0cmluZ1wiKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWU6IG51bWJlciB8IHN0cmluZyA9IGN1clRhZy52YWx1ZTtcbiAgICBpZiAodGFnVmFsdWVzTWFwLmhhcyh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBJbmNpZGVudChcIkR1cGxpY2F0ZVRhZ1ZhbHVlXCIsIFwiVGhlIHRhZyB2YWx1ZXMgbXVzdCBiZSB1bmlxdWVcIik7XG4gICAgfVxuICAgIHRhZ1ZhbHVlc01hcC5zZXQodmFsdWUsIHZhcmlhbnQpO1xuICB9XG4gIGlmICh0YWdCYXNlVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEluY2lkZW50KFwiTm9WYXJpYW50c1wiKTtcbiAgfVxuICByZXR1cm4gW3RhZ1ZhbHVlc01hcCwgdGFnQmFzZVR5cGUhXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBtYXAgZnJvbSB0aGUgc2VyaWFsaXplZCBsYWJlbCB0byB0aGUgY29ycmVzcG9uZGluZyB0eXBlIHZhcmlhbnRcbiAqXG4gKiBAcGFyYW0gdGFnTmFtZSBOYW1lIG9mIHRoZSB0YWcgcHJvcGVydHlcbiAqIEBwYXJhbSB2YXJpYW50cyBUeXBlIHZhcmlhbnRzIGZvciB0aGlzIHVuaW9uLCB0aGVzZSBzaG91bGQgYWxsIGJlIHRhZ2dlZCBkb2N1bWVudCB0eXBlc1xuICogQHBhcmFtIHRhZ0Jhc2VUeXBlIFRoZSB1bmRlcmx5aW5nIHR5cGUgb2YgYWxsIHRoZSB2YXJpYW50cyAobXVzdCBiZSBhIHNpbXBsZSBlbnVtIGN1cnJlbnRseSlcbiAqIEBwYXJhbSBzZXJpYWxpemVyIFRoZSBzZXJpYWxpemVyIHRvIHVzZSB0byBjcmVhdGUgdGhlIG1hcFxuICogQHJldHVybiBNYXAgZnJvbSB0aGUgc2VyaWFsaXplZCBsYWJlbCB0byB0aGUgY29ycmVzcG9uZGluZyB0eXBlIHZhcmlhbnQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU91dFZhbHVlc01hcDxUIGV4dGVuZHMge30+KFxuICB0YWdOYW1lOiBrZXlvZiBULFxuICB2YXJpYW50czogRG9jdW1lbnRUeXBlPFQ+W10sXG4gIHRhZ0Jhc2VUeXBlOiBhbnksXG4gIHNlcmlhbGl6ZXI6IFNlcmlhbGl6ZXIsXG4pOiBNYXA8bnVtYmVyIHwgc3RyaW5nLCBEb2N1bWVudFR5cGU8VD4+IHtcbiAgY29uc3QgcmVzdWx0OiBNYXA8bnVtYmVyIHwgc3RyaW5nLCBEb2N1bWVudFR5cGU8VD4+ID0gbmV3IE1hcCgpO1xuICBmb3IgKGNvbnN0IHZhcmlhbnQgb2YgdmFyaWFudHMpIHtcbiAgICBjb25zdCBjdXJUYWc6IExpdGVyYWxUeXBlPGFueT4gPSB2YXJpYW50LnByb3BlcnRpZXNbdGFnTmFtZV0udHlwZSBhcyBMaXRlcmFsVHlwZTxhbnk+O1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQ6IGFueSA9IHNlcmlhbGl6ZXIud3JpdGUodGFnQmFzZVR5cGUsIChjdXJUYWcgYXMgTGl0ZXJhbFR5cGU8YW55PikudmFsdWUpO1xuICAgIGlmICghKHR5cGVvZiBzZXJpYWxpemVkID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBzZXJpYWxpemVkID09PSBcInN0cmluZ1wiKSkge1xuICAgICAgdGhyb3cgbmV3IEluY2lkZW50KFwiSW52YWxpZFNlcmlhbGl6ZWRWYWx1ZVwiLCB7c2VyaWFsaXplZH0pO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LmhhcyhzZXJpYWxpemVkKSkge1xuICAgICAgdGhyb3cgbmV3IEluY2lkZW50KFwiRHVwbGljYXRlT3V0VGFnVmFsdWVcIiwgXCJUaGUgc2VyaWFsaXplZCB0YWcgdmFsdWVzIG11c3QgYmUgdW5pcXVlXCIpO1xuICAgIH1cbiAgICByZXN1bHQuc2V0KHNlcmlhbGl6ZWQsIHZhcmlhbnQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHRvVW5pb25PcHRpb25zPFQgZXh0ZW5kcyB7fT4ob3B0aW9uczogVGFnZ2VkVW5pb25UeXBlT3B0aW9uczxUPik6IHVuaW9uLlVuaW9uVHlwZU9wdGlvbnM8VCwgYW55LCBhbnksIGFueT4ge1xuICBjb25zdCB0YWdOYW1lOiBrZXlvZiBUID0gb3B0aW9ucy50YWc7XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTptYXgtbGluZS1sZW5ndGhcbiAgY29uc3QgW3RhZ1ZhbHVlc01hcCwgdGFnQmFzZVR5cGVdOiBbTWFwPG51bWJlciB8IHN0cmluZywgRG9jdW1lbnRUeXBlPFQ+PiwgSnNvblNlcmlhbGl6ZXI8YW55LCBhbnksIGFueT5dID0gZ2V0VGFnVmFsdWVzV2l0aEJhc2VUeXBlKG9wdGlvbnMpO1xuICBjb25zdCBvdXRWYWx1ZXNNYXBzOiBXZWFrTWFwPFNlcmlhbGl6ZXIsIE1hcDxudW1iZXIgfCBzdHJpbmcsIERvY3VtZW50VHlwZTxUPj4+ID0gbmV3IFdlYWtNYXAoKTtcblxuICBjb25zdCBtYXRjaGVyOiB1bmlvbi5NYXRjaGVyPFQ+ID0gKHZhbHVlOiBhbnkpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdGFnVmFsdWVzTWFwLmdldCh2YWx1ZVt0YWdOYW1lXSk7XG4gIH07XG5cbiAgY29uc3QgdHJ1c3RlZE1hdGNoZXI6IHVuaW9uLlRydXN0ZWRNYXRjaGVyPFQ+ID0gKHZhbHVlOiBUKSA9PiB7XG4gICAgcmV0dXJuIHRhZ1ZhbHVlc01hcC5nZXQoKDxhbnk+IHZhbHVlKVt0YWdOYW1lXSkhO1xuICB9O1xuXG4gIGNvbnN0IHJlYWRNYXRjaGVyOiB1bmlvbi5SZWFkTWF0Y2hlcjxUPiA9IChpbnB1dDogYW55LCBzZXJpYWxpemVyOiBTZXJpYWxpemVyKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IG91dFZhbHVlc01hcDogTWFwPG51bWJlciB8IHN0cmluZywgRG9jdW1lbnRUeXBlPFQ+PiB8IHVuZGVmaW5lZCA9IG91dFZhbHVlc01hcHMuZ2V0KHNlcmlhbGl6ZXIpO1xuICAgIGlmIChvdXRWYWx1ZXNNYXAgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3V0VmFsdWVzTWFwID0gY3JlYXRlT3V0VmFsdWVzTWFwKHRhZ05hbWUsIG9wdGlvbnMudmFyaWFudHMsIHRhZ0Jhc2VUeXBlLCBzZXJpYWxpemVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dFZhbHVlc01hcC5nZXQoaW5wdXRbdGFnTmFtZV0pO1xuICB9O1xuXG4gIGNvbnN0IHJlYWRUcnVzdGVkTWF0Y2hlcjogdW5pb24uUmVhZFRydXN0ZWRNYXRjaGVyPFQ+ID0gKGlucHV0OiBhbnksIHNlcmlhbGl6ZXI6IFNlcmlhbGl6ZXIpOiBUeXBlPFQ+ID0+IHtcbiAgICBsZXQgb3V0VmFsdWVzTWFwOiBNYXA8bnVtYmVyIHwgc3RyaW5nLCBEb2N1bWVudFR5cGU8VD4+IHwgdW5kZWZpbmVkID0gb3V0VmFsdWVzTWFwcy5nZXQoc2VyaWFsaXplcik7XG4gICAgaWYgKG91dFZhbHVlc01hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvdXRWYWx1ZXNNYXAgPSBjcmVhdGVPdXRWYWx1ZXNNYXAodGFnTmFtZSwgb3B0aW9ucy52YXJpYW50cywgdGFnQmFzZVR5cGUsIHNlcmlhbGl6ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0VmFsdWVzTWFwLmdldChpbnB1dFt0YWdOYW1lXSkhO1xuICB9O1xuXG4gIHJldHVybiB7dmFyaWFudHM6IG9wdGlvbnMudmFyaWFudHMsIG1hdGNoZXIsIHRydXN0ZWRNYXRjaGVyLCByZWFkTWF0Y2hlciwgcmVhZFRydXN0ZWRNYXRjaGVyfTtcbn1cblxuZXhwb3J0IGNsYXNzIFRhZ2dlZFVuaW9uVHlwZTxUIGV4dGVuZHMge30+IGV4dGVuZHMgdW5pb24uVW5pb25UeXBlPFQ+IHtcbiAgY29uc3RydWN0b3Iob3B0aW9uczogTGF6eTxUYWdnZWRVbmlvblR5cGVPcHRpb25zPFQ+Pikge1xuICAgIHN1cGVyKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIgPyAoKSA9PiB0b1VuaW9uT3B0aW9ucyhvcHRpb25zKCkpIDogdG9Vbmlvbk9wdGlvbnMob3B0aW9ucykpO1xuICB9XG5cbiAgdG9KU09OKCk6IGpzb24uVHlwZSB7XG4gICAgdGhyb3cgY3JlYXRlTm90SW1wbGVtZW50ZWRFcnJvcihcIlRhZ2dlZFVuaW9uVHlwZSN0b0pTT05cIik7XG4gIH1cblxuICBkaWZmKG9sZFZhbDogVCwgbmV3VmFsOiBUKTogRGlmZiB8IHVuZGVmaW5lZCB7XG4gICAgdGhyb3cgY3JlYXRlTm90SW1wbGVtZW50ZWRFcnJvcihcIlRhZ2dlZFVuaW9uVHlwZSNkaWZmXCIpO1xuICB9XG5cbiAgcGF0Y2gob2xkVmFsOiBULCBkaWZmOiBEaWZmIHwgdW5kZWZpbmVkKTogVCB7XG4gICAgdGhyb3cgY3JlYXRlTm90SW1wbGVtZW50ZWRFcnJvcihcIlRhZ2dlZFVuaW9uVHlwZSNwYXRjaFwiKTtcbiAgfVxuXG4gIHJldmVyc2VEaWZmKGRpZmY6IERpZmYgfCB1bmRlZmluZWQpOiBEaWZmIHwgdW5kZWZpbmVkIHtcbiAgICB0aHJvdyBjcmVhdGVOb3RJbXBsZW1lbnRlZEVycm9yKFwiVGFnZ2VkVW5pb25UeXBlI3JldmVyc2VEaWZmXCIpO1xuICB9XG5cbiAgc3F1YXNoKGRpZmYxOiBEaWZmIHwgdW5kZWZpbmVkLCBkaWZmMjogRGlmZiB8IHVuZGVmaW5lZCk6IERpZmYgfCB1bmRlZmluZWQge1xuICAgIHRocm93IGNyZWF0ZU5vdEltcGxlbWVudGVkRXJyb3IoXCJUYWdnZWRVbmlvblR5cGUjc3F1YXNoXCIpO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6Ii4uIn0=
