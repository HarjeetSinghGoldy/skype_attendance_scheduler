import { Lazy, VersionedType } from "../types";
export declare type Name = "ucs2-string";
export declare const name: Name;
export declare namespace json {
    type Input = string;
    type Output = string;
    interface Type {
        name: Name;
        allowUnicodeRegExp: boolean;
        pattern?: [string, string];
        lowerCase: boolean;
        /**
         * @see [[Ucs2StringTypeOptions.trimmed]]
         */
        trimmed: boolean;
        minLength?: number;
        maxLength: number;
    }
}
export declare type Diff = [string, string];
export interface Ucs2StringTypeOptions {
    allowUnicodeRegExp?: boolean;
    pattern?: RegExp;
    lowerCase?: boolean;
    /**
     * The string cannot start or end with any of the following whitespace and line terminator
     * characters:
     *
     * - Unicode Character 'CHARACTER TABULATION' (U+0009)
     * - Unicode Character 'LINE FEED (LF)' (U+000A)
     * - Unicode Character 'LINE TABULATION' (U+000B)
     * - Unicode Character 'FORM FEED (FF)' (U+000C)
     * - Unicode Character 'CARRIAGE RETURN (CR)' (U+000D)
     * - Unicode Character 'SPACE' (U+0020)
     * - Unicode Character 'NO-BREAK SPACE' (U+00A0)
     * - Unicode Character 'LINE SEPARATOR' (U+2028)
     * - Unicode Character 'PARAGRAPH SEPARATOR' (U+2029)
     * - Unicode Character 'ZERO WIDTH NO-BREAK SPACE' (U+FEFF)
     * - Any other Unicode character of the "Separator, space" (Zs) general category
     *
     * @see <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim>
     * @see <http://www.fileformat.info/info/unicode/category/Zs/list.htm>
     */
    trimmed?: boolean;
    minLength?: number;
    maxLength: number;
}
/**
 * The type used for simple Javascript strings.
 * Javascript strings expose characters as UCS2 code units. This is a fixed-size encoding that supports the unicode
 * codepoints from U+000000 to U+00FFFF (Basic Multilingual Plane or BMP). Displaying larger codepoints is
 * a property of the environment based on UTF-16 surrogate pairs. Unicode does not, and will never, assign
 * characters to the codepoints from U+OOD800 to U+00DFFF. These spare codepoints allows UTF16 to combine
 * codeunits from 0xd800 to 0xdfff in pairs (called surrogate pairs) to represent codepoints from supplementary planes.
 * This transformation happens during the transition from codeunits to codepoints in UTF-16.
 * In UCS2, the codeunits from 0xd800 to 0xdfff directly produce codepoints in the range from U+OOD8OO to
 * U+OODFF. Then, the display might merge these codepoints into higher codepoints during the rendering.
 *
 *
 * Lets take an example (all the numbers are in hexadecimal):
 *
 * ```
 *                                         +---+---+---+---+---+---+
 * Bytes                                   | 00| 41| d8| 34| dd| 1e|
 *                                         +---+---+---+---+---+---+
 * UTF-16BE codeunits                      | 0x0041| 0xd834| 0xdd1e|
 *                                         +-------+-------+-------+
 * Codepoints (from UTF-16BE)              |  U+41 |   U+01D11E    |
 *                                         +-------+---------------+
 * Displayed (from UTF-16BE)               |   A   |       ùÑû       |
 *                                         +-------+-------+-------+
 * UCS2 codeunits                          | 0x0041| 0xd834| 0xdd1e|
 *                                         +-------+-------+-------+
 * Codepoints (from UCS2BE)                |  U+41 | U+D834| U+DD1E|  <- This is what Javascript sees
 *                                         +-------+-------+-------+
 * Displayed (from UCS2BE)                 |   A   |   ÔøΩ   |   ÔøΩ   |  <- This is what the user may see
 *                                         +-------+-------+-------+
 * Displayed (from UCS2BE with surrogates) |   A   |       ùÑû       |  <- This is what the user may see
 *                                         +-------+---------------+
 * ```
 *
 * The most important takeaway is that codepoints outside of the BMP are a property of the display, not of
 * the Javascript string.
 * This is the cause of multiple issues.
 * - Surrogate halves are exposed as distinct characters: `"ùÑû".length === 2`
 * - Unmatched surrogate halves are allowed: `"\ud834"`
 * - Surrogate pairs in the wrong order are allowed: `"\udd1e\ud834"`
 *
 * If you need to support the full unicode range by manipulating codepoints instead of UCS2 character codes, you may
 * want to use CodepointString or CodepointArray instead of Ucs2String.
 *
 * PS: This type does not deal with Unicdoe normalization either. Use CodepointString and CodepointArray if you need
 * it.
 */
export declare class Ucs2StringType implements VersionedType<string, json.Input, json.Output, Diff> {
    readonly name: Name;
    readonly allowUnicodeRegExp: boolean;
    readonly pattern?: RegExp;
    readonly lowerCase: boolean;
    readonly trimmed: boolean;
    readonly minLength?: number;
    readonly maxLength: number;
    private _options;
    constructor(options: Lazy<Ucs2StringTypeOptions>);
    static fromJSON(options: json.Type): Ucs2StringType;
    toJSON(): json.Type;
    readTrustedJson(input: json.Output): string;
    readJson(input: any): string;
    writeJson(val: string): json.Output;
    testError(val: string): Error | undefined;
    test(val: string): boolean;
    equals(val1: string, val2: string): boolean;
    clone(val: string): string;
    diff(oldVal: string, newVal: string): Diff | undefined;
    patch(oldVal: string, diff: Diff | undefined): string;
    reverseDiff(diff: Diff | undefined): Diff | undefined;
    squash(diff1: Diff | undefined, diff2: Diff | undefined): Diff | undefined;
    private _applyOptions();
}
