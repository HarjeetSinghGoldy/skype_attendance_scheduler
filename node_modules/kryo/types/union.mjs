import { Incident } from "incident";
import { lazyProperties } from "../_helpers/lazy-properties";
import { createLazyOptionsError } from "../errors/lazy-options";
import { createNotImplementedError } from "../errors/not-implemented";
import { JSON_SERIALIZER } from "../json/index";
export const name = "union";
export class UnionType {
    constructor(options) {
        this.name = name;
        // TODO: Remove once TS 2.7 is better supported by editors
        this.variants = undefined;
        this.matcher = undefined;
        this.trustedMatcher = undefined;
        this.readMatcher = undefined;
        this.readTrustedMatcher = undefined;
        this._options = options;
        if (typeof options !== "function") {
            this._applyOptions();
        }
        else {
            lazyProperties(this, this._applyOptions, ["variants", "matcher", "trustedMatcher", "readMatcher", "readTrustedMatcher"]);
        }
    }
    toJSON() {
        throw createNotImplementedError("UnionType#toJSON");
    }
    readTrustedJsonWithVariant(input) {
        const variant = this.readTrustedMatcher(input, JSON_SERIALIZER);
        // TODO(demurgos): Avoid casting
        return [variant.readTrustedJson(input), variant];
    }
    readJsonWithVariant(input) {
        const variant = this.readMatcher(input, JSON_SERIALIZER);
        if (variant === undefined) {
            throw new Incident("UnknownUnionVariant", "Unknown union variant");
        }
        // TODO(demurgos): Avoid casting
        return [variant.readJson(input), variant];
    }
    readTrustedJson(input) {
        return this.readTrustedJsonWithVariant(input)[0];
    }
    readJson(input) {
        return this.readJsonWithVariant(input)[0];
    }
    writeJson(val) {
        // TODO(demurgos): Avoid casting
        return this.trustedMatcher(val).writeJson(val);
    }
    testError(val) {
        const type = this.matcher(val);
        if (type === undefined) {
            return new Incident("UnknownUnionVariant", "Unknown union variant");
        }
        return type.testError(val);
    }
    testWithVariant(val) {
        const variant = this.matcher(val);
        if (variant === undefined) {
            return [false, undefined];
        }
        return [variant.test(val), variant];
    }
    test(val) {
        const type = this.matcher(val);
        if (type === undefined) {
            return false;
        }
        return type.test(val);
    }
    // TODO: Always return true?
    equals(val1, val2) {
        const type1 = this.trustedMatcher(val1);
        const type2 = this.trustedMatcher(val2);
        return type1 === type2 && type1.equals(val1, val2);
    }
    clone(val) {
        return this.trustedMatcher(val).clone(val);
    }
    diff(oldVal, newVal) {
        throw createNotImplementedError("UnionType#diff");
    }
    patch(oldVal, diff) {
        throw createNotImplementedError("UnionType#patch");
    }
    reverseDiff(diff) {
        throw createNotImplementedError("UnionType#reverseDiff");
    }
    squash(diff1, diff2) {
        throw createNotImplementedError("UnionType#squash");
    }
    _applyOptions() {
        if (this._options === undefined) {
            throw createLazyOptionsError(this);
        }
        const options = typeof this._options === "function"
            ? this._options()
            : this._options;
        delete this._options;
        const variants = options.variants;
        const matcher = options.matcher;
        let trustedMatcher;
        if (options.trustedMatcher !== undefined) {
            trustedMatcher = options.trustedMatcher;
        }
        else {
            trustedMatcher = (value) => {
                const variant = matcher(value);
                if (variant === undefined) {
                    throw new Incident("UnknownUnionVariant", "Unknown union variant");
                }
                return variant;
            };
        }
        const readMatcher = options.readMatcher;
        let readTrustedMatcher;
        if (options.readTrustedMatcher !== undefined) {
            readTrustedMatcher = options.readTrustedMatcher;
        }
        else {
            readTrustedMatcher = (input, serializer) => {
                const variant = readMatcher(input, serializer);
                if (variant === undefined) {
                    throw new Incident("UnknownUnionVariant", { input, serializer }, "Unknown union variant");
                }
                return variant;
            };
        }
        Object.assign(this, { variants, matcher, trustedMatcher, readMatcher, readTrustedMatcher });
        Object.freeze(this);
    }
}
