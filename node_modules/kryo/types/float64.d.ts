import { Lazy, VersionedType } from "../types";
export declare type Name = "float64";
export declare const name: Name;
export declare namespace json {
    interface Type {
        readonly name: Name;
        readonly allowNaN: boolean;
        readonly allowInfinity: boolean;
    }
}
export declare type Diff = [number, number];
/**
 * Options for the `Float64` meta-type.
 */
export interface Float64TypeOptions {
    /**
     * Accept `NaN` values.
     * If you enable this option, the `test` method will treat two `NaN` values as equal.
     *
     * @default `false`
     */
    readonly allowNaN?: boolean;
    /**
     * Accept `+Infinity` and `-Infinity`.
     *
     * @default `false`
     */
    readonly allowInfinity?: boolean;
}
export declare class Float64Type implements VersionedType<number, number | "NaN" | "+Infinity" | "-Infinity", number | "NaN" | "+Infinity" | "-Infinity", Diff> {
    readonly name: Name;
    readonly allowNaN: boolean;
    readonly allowInfinity: boolean;
    private _options;
    constructor(options?: Lazy<Float64TypeOptions>);
    static fromJSON(options: json.Type): Float64Type;
    toJSON(): json.Type;
    readTrustedJson(input: number | "NaN" | "+Infinity" | "-Infinity"): number;
    readJson(input: number | "NaN" | "+Infinity" | "-Infinity"): number;
    writeJson(val: number): number | "NaN" | "+Infinity" | "-Infinity";
    testError(val: number): Error | undefined;
    test(val: number): boolean;
    equals(val1: number, val2: number): boolean;
    clone(val: number): number;
    diff(oldVal: number, newVal: number): Diff | undefined;
    patch(oldVal: number, diff: Diff | undefined): number;
    reverseDiff(diff: Diff | undefined): Diff | undefined;
    squash(diff1: Diff | undefined, diff2: Diff | undefined): Diff | undefined;
    private _applyOptions();
}
