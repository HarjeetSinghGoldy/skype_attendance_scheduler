import { Incident } from "incident";
import { lazyProperties } from "../_helpers/lazy-properties";
import { rename } from "../case-style";
import { createInvalidTypeError } from "../errors/invalid-type";
import { createLazyOptionsError } from "../errors/lazy-options";
import { createNotImplementedError } from "../errors/not-implemented";
export const name = "simple-enum";
/**
 * Supports enums from keys that are valid Javascript identifiers to unique integer values
 */
export class SimpleEnumType {
    constructor(options) {
        this.name = name;
        // TODO: Remove once TS 2.7 is better supported by editors
        this.enum = undefined;
        this.outputNameToValue = undefined;
        this.valueToOutputName = undefined;
        this._options = options;
        if (typeof options !== "function") {
            this._applyOptions();
        }
        else {
            lazyProperties(this, this._applyOptions, ["enum", "rename", "outputNameToValue", "valueToOutputName"]);
        }
    }
    static fromJSON() {
        throw createNotImplementedError("SimpleEnumType.fromJSON");
    }
    toJSON() {
        throw createNotImplementedError("SimpleEnumType#toJSON");
    }
    readTrustedJson(input) {
        return this.outputNameToValue[input];
    }
    readJson(input) {
        if (typeof input !== "string") {
            throw createInvalidTypeError("string", input);
        }
        if (!this.outputNameToValue.hasOwnProperty(input)) {
            throw Incident("Unknown enum variant name", input);
        }
        return this.outputNameToValue[input];
    }
    writeJson(val) {
        return this.valueToOutputName[val];
    }
    testError(val) {
        if (typeof val !== "number") {
            return createInvalidTypeError("number", val);
        }
        // TODO(demurgos): Remove <number> once typedoc supports it
        if (isNaN(val) || val === Infinity || val === -Infinity || (val | 0) !== val) {
            return createInvalidTypeError("int32", val);
        }
        if (!this.enum.hasOwnProperty(val)) {
            return Incident("UnknownVariantError", { value: val }, "Unknown enum variant value");
        }
        return undefined;
    }
    test(val) {
        return typeof val === "number" && this.enum.hasOwnProperty(val);
    }
    equals(val1, val2) {
        return val1 === val2;
    }
    clone(val) {
        return val;
    }
    diff(oldVal, newVal) {
        return newVal === oldVal ? undefined : newVal - oldVal;
    }
    patch(oldVal, diff) {
        return diff === undefined ? oldVal : oldVal + diff;
    }
    reverseDiff(diff) {
        /* tslint:disable-next-line:strict-boolean-expressions */
        return diff && -diff;
    }
    squash(diff1, diff2) {
        if (diff1 === undefined) {
            return diff2;
        }
        else if (diff2 === undefined) {
            return diff1;
        }
        return diff2 === -diff1 ? undefined : diff1 + diff2;
    }
    _applyOptions() {
        if (this._options === undefined) {
            throw createLazyOptionsError(this);
        }
        const options = typeof this._options === "function" ? this._options() : this._options;
        const baseEnum = options.enum;
        const renameAll = options.rename;
        const outputNameToValue = {};
        const valueToOutputName = {};
        for (const key in baseEnum) {
            if (/^\d+$/.test(key)) {
                continue;
            }
            const value = options.enum[key];
            if (typeof value !== "number") {
                throw createInvalidTypeError("number", value);
            }
            if (!baseEnum.hasOwnProperty(value) || !baseEnum.hasOwnProperty(value)) {
                throw new Incident("NotSimpleEnum", "Not owned key or value");
            }
            if (baseEnum[value] !== key) {
                throw new Incident("NotReversibleEnum", "enum[enum[key]] !== key");
            }
            let renamed;
            if (renameAll === undefined) {
                renamed = key;
            }
            else {
                renamed = rename(key, renameAll);
            }
            outputNameToValue[renamed] = value;
            valueToOutputName[value] = renamed;
        }
        Object.assign(this, { enum: baseEnum, rename: renameAll, outputNameToValue, valueToOutputName });
        Object.freeze(this);
    }
}
