import { Incident } from "incident";
import { lazyProperties } from "../_helpers/lazy-properties";
import { rename } from "../case-style";
import { createInvalidDocumentError } from "../errors/invalid-document";
import { createInvalidTypeError } from "../errors/invalid-type";
import { createLazyOptionsError } from "../errors/lazy-options";
import { createNotImplementedError } from "../errors/not-implemented";
import { JSON_SERIALIZER } from "../json";
export const name = "document";
// We use an `any` cast because of the `properties` property.
// tslint:disable-next-line:variable-name
export const DocumentType = class {
    constructor(options) {
        this.name = name;
        // TODO: Remove once TS 2.7 is better supported by editors
        this.ignoreExtraKeys = undefined;
        this.properties = undefined;
        this.keys = undefined;
        this._options = options;
        if (typeof options !== "function") {
            this._applyOptions();
        }
        else {
            lazyProperties(this, this._applyOptions, ["ignoreExtraKeys", "properties", "rename", "keys"]);
        }
    }
    static fromJSON(options) {
        throw createNotImplementedError("DocumentType.fromJSON");
    }
    toJSON() {
        throw createNotImplementedError("DocumentType#toJSON");
    }
    readTrustedJson(input) {
        const result = {}; // Object.create(null);
        for (const [key, outKey] of this.keys) {
            const descriptor = this.properties[key];
            const jsonValue = Reflect.get(input, outKey);
            if (jsonValue === undefined) {
                result[key] = undefined;
            }
            else {
                result[key] = JSON_SERIALIZER.readTrusted(descriptor.type, jsonValue);
            }
        }
        return result;
    }
    readJson(input) {
        const extra = this.ignoreExtraKeys ? undefined : new Set(Object.keys(input));
        const missing = new Set();
        const invalid = new Map();
        const result = {}; // Object.create(null);
        for (const [key, outKey] of this.keys) {
            if (extra !== undefined) {
                extra.delete(outKey);
            }
            const descriptor = this.properties[key];
            const jsonValue = Reflect.get(input, outKey);
            if (jsonValue === undefined) {
                if (descriptor.optional) {
                    result[key] = undefined;
                }
                else {
                    missing.add(key);
                }
                continue;
            }
            try {
                result[key] = JSON_SERIALIZER.read(descriptor.type, jsonValue);
            }
            catch (err) {
                invalid.set(key, err);
            }
        }
        if (extra !== undefined && extra.size > 0 || missing.size > 0 || invalid.size > 0) {
            throw createInvalidDocumentError({ extra, missing, invalid });
        }
        return result;
    }
    writeJson(val) {
        const result = {}; // Object.create(null);
        for (const [key, outKey] of this.keys) {
            const descriptor = this.properties[key];
            const value = val[key];
            if (value === undefined) {
                Reflect.set(result, outKey, undefined);
            }
            else {
                Reflect.set(result, outKey, JSON_SERIALIZER.write(descriptor.type, value));
            }
        }
        return result;
    }
    testError(val) {
        if (typeof val !== "object" || val === null) {
            return createInvalidTypeError("object", val);
        }
        const extra = this.ignoreExtraKeys ? undefined : new Set(Object.keys(val));
        const missing = new Set();
        const invalid = new Map();
        for (const key in this.properties) {
            if (extra !== undefined) {
                extra.delete(key);
            }
            const descriptor = this.properties[key];
            const propertyValue = val[key];
            if (propertyValue === undefined) {
                if (!descriptor.optional) {
                    missing.add(key);
                }
                continue;
            }
            const error = descriptor.type.testError(propertyValue);
            if (error !== undefined) {
                invalid.set(key, error);
            }
        }
        if (extra !== undefined && extra.size > 0 || missing.size > 0 || invalid.size > 0) {
            return createInvalidDocumentError({ extra, missing, invalid });
        }
        return undefined;
    }
    test(val) {
        if (typeof val !== "object" || val === null) {
            return false;
        }
        const extra = this.ignoreExtraKeys ? undefined : new Set(Object.keys(val));
        for (const key in this.properties) {
            if (extra !== undefined) {
                extra.delete(key);
            }
            const descriptor = this.properties[key];
            const propertyValue = val[key];
            if (propertyValue === undefined) {
                if (!descriptor.optional) {
                    return false;
                }
            }
            else if (!descriptor.type.test(propertyValue)) {
                return false;
            }
        }
        return extra === undefined || extra.size === 0;
    }
    equals(val1, val2) {
        for (const key in this.properties) {
            const descriptor = this.properties[key];
            if (!descriptor.optional) {
                if (!descriptor.type.equals(val1[key], val2[key])) {
                    return false;
                }
                continue;
            }
            if (val1[key] === undefined && val2[key] === undefined) {
                continue;
            }
            if (val1[key] === undefined || val2[key] === undefined || !descriptor.type.equals(val1[key], val2[key])) {
                return false;
            }
        }
        return true;
    }
    clone(val) {
        const result = {}; // Object.create(null);
        for (const key in this.properties) {
            result[key] = val[key] === undefined ? undefined : this.properties[key].type.clone(val[key]);
        }
        return result;
    }
    diff(oldVal, newVal) {
        let equal = true;
        const result = { set: {}, unset: {}, update: {} };
        for (const key in this.properties) {
            // TODO: Remove cast
            const descriptor = this.properties[key];
            const oldMember = oldVal[key];
            const newMember = newVal[key];
            if (oldMember !== undefined) {
                if (newMember !== undefined) {
                    const diff = descriptor.type.diff(oldMember, newMember);
                    if (diff !== undefined) {
                        result.update[key] = diff;
                        equal = false;
                    }
                }
                else {
                    result.unset[key] = descriptor.type.clone(oldMember);
                    equal = false;
                }
            }
            else {
                if (newMember === undefined) {
                    result.set[key] = descriptor.type.clone(newMember);
                    equal = false;
                }
            }
        }
        return equal ? undefined : result;
    }
    patch(oldVal, diff) {
        const result = this.clone(oldVal);
        if (diff === undefined) {
            return result;
        }
        for (const key in diff.set) {
            result[key] = this.properties[key].type.clone(diff.set[key]);
        }
        for (const key in diff.unset) {
            Reflect.deleteProperty(result, key);
        }
        for (const key in diff.update) {
            // TODO: Remove cast
            result[key] = this.properties[key].type.patch(result[key], diff.update[key]);
        }
        return result;
    }
    reverseDiff(diff) {
        if (diff === undefined) {
            return undefined;
        }
        const result = { set: {}, unset: {}, update: {} };
        for (const key in diff.unset) {
            result.set[key] = this.properties[key].type.clone(diff.unset[key]);
        }
        for (const key in diff.set) {
            result.unset[key] = this.properties[key].type.clone(diff.set[key]);
        }
        for (const key in diff.update) {
            // TODO: Remove cast
            result.update[key] = this.properties[key].type.reverseDiff(diff.update[key]);
        }
        return result;
    }
    squash(diff1, diff2) {
        throw createNotImplementedError("DocumentType#squash");
    }
    _applyOptions() {
        if (this._options === undefined) {
            throw createLazyOptionsError(this);
        }
        const options = typeof this._options === "function" ?
            this._options() :
            this._options;
        const ignoreExtraKeys = options.ignoreExtraKeys || false;
        const properties = options.properties;
        const renameAll = options.rename;
        const keys = renameKeys(properties, renameAll);
        Object.assign(this, { ignoreExtraKeys, properties, rename: renameAll, keys });
        Object.freeze(this);
    }
};
export function renameKeys(obj, renameAll) {
    const keys = Object.keys(obj);
    const result = new Map();
    const outKeys = new Set();
    for (const key of keys) {
        const renamed = renameAll === undefined ? key : rename(key, renameAll);
        result.set(key, renamed);
        if (outKeys.has(renamed)) {
            throw new Incident("NonBijectiveKeyRename", "Some keys are the same after renaming");
        }
        outKeys.add(renamed);
    }
    return result;
}
