import { Incident } from "incident";
import { createNotImplementedError } from "../errors/not-implemented";
import { LiteralType } from "./literal";
import { SimpleEnumType } from "./simple-enum";
import * as union from "./union";
export const name = "tagged-union";
function getTagValuesWithBaseType(options) {
    const tagName = options.tag;
    let tagBaseType = undefined;
    const tagValuesMap = new Map();
    for (const variant of options.variants) {
        if (variant === undefined) {
            // tslint:disable-next-line:max-line-length
            throw new Incident("UndefinedVariant", { variants: options.variants }, "The supplied TaggedUnion options contain undefined variants. If you have circular dependencies, try to use lazy options.");
        }
        if (!(tagName in variant.properties)) {
            throw new Incident("TagNotFound", "Tag not found in variant of tagged union");
        }
        if (!(variant.properties[tagName].type instanceof LiteralType)) {
            throw new Incident("NonLiteralTag", "Tag property must be a literal type");
        }
        const curTag = variant.properties[tagName].type;
        if (tagBaseType === undefined) {
            // TODO: Use type name instead of instanceof
            if (curTag.type instanceof SimpleEnumType) {
                tagBaseType = curTag.type;
            }
            else {
                throw new Incident("InvalidTagBaseType", "The base type of a tag property must be a simple enum");
            }
        }
        else if (curTag.type !== tagBaseType) {
            throw new Incident("MixedTagBaseType", "All the variants of a tag property must have the same base type");
        }
        if (!(typeof curTag.value === "number" || typeof curTag.value === "string")) {
            throw new Incident("InvalidTagValue", "The value of a tag property must be a number or string");
        }
        const value = curTag.value;
        if (tagValuesMap.has(value)) {
            throw new Incident("DuplicateTagValue", "The tag values must be unique");
        }
        tagValuesMap.set(value, variant);
    }
    if (tagBaseType === undefined) {
        throw new Incident("NoVariants");
    }
    return [tagValuesMap, tagBaseType];
}
/**
 * Create a map from the serialized label to the corresponding type variant
 *
 * @param tagName Name of the tag property
 * @param variants Type variants for this union, these should all be tagged document types
 * @param tagBaseType The underlying type of all the variants (must be a simple enum currently)
 * @param serializer The serializer to use to create the map
 * @return Map from the serialized label to the corresponding type variant.
 */
function createOutValuesMap(tagName, variants, tagBaseType, serializer) {
    const result = new Map();
    for (const variant of variants) {
        const curTag = variant.properties[tagName].type;
        const serialized = serializer.write(tagBaseType, curTag.value);
        if (!(typeof serialized === "number" || typeof serialized === "string")) {
            throw new Incident("InvalidSerializedValue", { serialized });
        }
        if (result.has(serialized)) {
            throw new Incident("DuplicateOutTagValue", "The serialized tag values must be unique");
        }
        result.set(serialized, variant);
    }
    return result;
}
function toUnionOptions(options) {
    const tagName = options.tag;
    // tslint:disable-next-line:max-line-length
    const [tagValuesMap, tagBaseType] = getTagValuesWithBaseType(options);
    const outValuesMaps = new WeakMap();
    const matcher = (value) => {
        if (typeof value !== "object" || value === null) {
            return undefined;
        }
        return tagValuesMap.get(value[tagName]);
    };
    const trustedMatcher = (value) => {
        return tagValuesMap.get(value[tagName]);
    };
    const readMatcher = (input, serializer) => {
        if (typeof input !== "object" || input === null) {
            return undefined;
        }
        let outValuesMap = outValuesMaps.get(serializer);
        if (outValuesMap === undefined) {
            outValuesMap = createOutValuesMap(tagName, options.variants, tagBaseType, serializer);
        }
        return outValuesMap.get(input[tagName]);
    };
    const readTrustedMatcher = (input, serializer) => {
        let outValuesMap = outValuesMaps.get(serializer);
        if (outValuesMap === undefined) {
            outValuesMap = createOutValuesMap(tagName, options.variants, tagBaseType, serializer);
        }
        return outValuesMap.get(input[tagName]);
    };
    return { variants: options.variants, matcher, trustedMatcher, readMatcher, readTrustedMatcher };
}
export class TaggedUnionType extends union.UnionType {
    constructor(options) {
        super(typeof options === "function" ? () => toUnionOptions(options()) : toUnionOptions(options));
    }
    toJSON() {
        throw createNotImplementedError("TaggedUnionType#toJSON");
    }
    diff(oldVal, newVal) {
        throw createNotImplementedError("TaggedUnionType#diff");
    }
    patch(oldVal, diff) {
        throw createNotImplementedError("TaggedUnionType#patch");
    }
    reverseDiff(diff) {
        throw createNotImplementedError("TaggedUnionType#reverseDiff");
    }
    squash(diff1, diff2) {
        throw createNotImplementedError("TaggedUnionType#squash");
    }
}
